2020-10-03 17:12:36.569943: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
============================= test session starts =============================
platform win32 -- Python 3.6.12, pytest-6.0.2, py-1.9.0, pluggy-0.13.1
rootdir: C:\Users\mutation\Desktop\testcase\tests\keras\layers
plugins: flaky-3.7.0
collected 110 items

convolutional_test.py FFFFFFF....FF...........FFFFFFFFFF..FFFFFFFFFFFF.. [ 45%]
..............FFFF.......................................FFF             [100%]

================================== FAILURES ===================================
_________ test_causal_dilated_conv[layer_kwargs0-4-expected_output0] __________

layer_kwargs = {'dilation_rate': 1, 'filters': 1, 'kernel_initializer': 'ones', 'kernel_size': 2, ...}
input_length = 4, expected_output = [[[0], [1], [3], [5]]]

    @pytest.mark.skipif((K.backend() == 'cntk' and load_backend.dev.type() == 0),
                        reason='cntk only support dilated conv on GPU')
    @pytest.mark.parametrize(
        'layer_kwargs,input_length,expected_output',
        [
            # Causal
            ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'causal',
              'kernel_initializer': 'ones', 'use_bias': False},
             4, [[[0], [1], [3], [5]]]),
            # Non-causal
            ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'valid',
              'kernel_initializer': 'ones', 'use_bias': False},
             4, [[[1], [3], [5]]]),
            # Causal dilated with larger kernel size
            ({'filters': 1, 'kernel_size': 3, 'dilation_rate': 2, 'padding': 'causal',
              'kernel_initializer': 'ones', 'use_bias': False},
             10, np.float32([[[0], [1], [2], [4], [6], [9], [12], [15], [18], [21]]])),
        ]
    )
    def test_causal_dilated_conv(layer_kwargs, input_length, expected_output):
        input_data = np.reshape(np.arange(input_length, dtype='float32'),
                                (1, input_length, 1))
        layer_test(convolutional.Conv1D, input_data=input_data,
>                  kwargs=layer_kwargs, expected_output=expected_output)

convolutional_test.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'dilation_rate': 1, 'filters': 1, 'kernel_initializer': 'ones', 'kernel_size': 2, ...}
input_shape = (1, 4, 1), input_dtype = dtype('float32')
input_data = array([[[0.],
        [1.],
        [2.],
        [3.]]], dtype=float32)
expected_output = [[[0], [1], [3], [5]]]
expected_output_dtype = dtype('float32'), fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
Using TensorFlow backend.
WARNING:tensorflow:From C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\resource_variable_ops.py:1630: calling BaseResourceVariable.__init__ (from tensorflow.python.ops.resource_variable_ops) with constraint is deprecated and will be removed in a future version.
Instructions for updating:
If using Keras pass *_constraint arguments to layers.
2020-10-03 17:12:39.452755: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library nvcuda.dll
2020-10-03 17:12:39.592072: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:39.594940: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:39.598779: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:39.602356: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:39.604251: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:39.609450: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:39.612780: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:39.622587: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:39.623607: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:39.624230: I tensorflow/core/platform/cpu_feature_guard.cc:142] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2
2020-10-03 17:12:39.637509: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:39.638070: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:39.638440: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:39.638806: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:39.639167: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:39.639529: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:39.639876: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:39.640226: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:39.641115: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:40.603063: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:40.603481: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:40.603701: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:40.604443: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
WARNING:tensorflow:From C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:422: The name tf.global_variables is deprecated. Please use tf.compat.v1.global_variables instead.

2020-10-03 17:12:41.085495: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:43.210968: W tensorflow/stream_executor/cuda/redzone_allocator.cc:312] Internal: Invoking ptxas not supported on Windows
Relying on driver to perform ptx compilation. This message will be only logged once.
2020-10-03 17:12:43.235070: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
------------------------------ Captured log call ------------------------------
WARNING  tensorflow:deprecation.py:506 From C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\resource_variable_ops.py:1630: calling BaseResourceVariable.__init__ (from tensorflow.python.ops.resource_variable_ops) with constraint is deprecated and will be removed in a future version.
Instructions for updating:
If using Keras pass *_constraint arguments to layers.
WARNING  tensorflow:module_wrapper.py:139 From C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:422: The name tf.global_variables is deprecated. Please use tf.compat.v1.global_variables instead.
_________ test_causal_dilated_conv[layer_kwargs1-4-expected_output1] __________

layer_kwargs = {'dilation_rate': 1, 'filters': 1, 'kernel_initializer': 'ones', 'kernel_size': 2, ...}
input_length = 4, expected_output = [[[1], [3], [5]]]

    @pytest.mark.skipif((K.backend() == 'cntk' and load_backend.dev.type() == 0),
                        reason='cntk only support dilated conv on GPU')
    @pytest.mark.parametrize(
        'layer_kwargs,input_length,expected_output',
        [
            # Causal
            ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'causal',
              'kernel_initializer': 'ones', 'use_bias': False},
             4, [[[0], [1], [3], [5]]]),
            # Non-causal
            ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'valid',
              'kernel_initializer': 'ones', 'use_bias': False},
             4, [[[1], [3], [5]]]),
            # Causal dilated with larger kernel size
            ({'filters': 1, 'kernel_size': 3, 'dilation_rate': 2, 'padding': 'causal',
              'kernel_initializer': 'ones', 'use_bias': False},
             10, np.float32([[[0], [1], [2], [4], [6], [9], [12], [15], [18], [21]]])),
        ]
    )
    def test_causal_dilated_conv(layer_kwargs, input_length, expected_output):
        input_data = np.reshape(np.arange(input_length, dtype='float32'),
                                (1, input_length, 1))
        layer_test(convolutional.Conv1D, input_data=input_data,
>                  kwargs=layer_kwargs, expected_output=expected_output)

convolutional_test.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'dilation_rate': 1, 'filters': 1, 'kernel_initializer': 'ones', 'kernel_size': 2, ...}
input_shape = (1, 4, 1), input_dtype = dtype('float32')
input_data = array([[[0.],
        [1.],
        [2.],
        [3.]]], dtype=float32)
expected_output = [[[1], [3], [5]]], expected_output_dtype = dtype('float32')
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:44.812255: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:44.812844: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:44.813188: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:44.813528: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:44.813867: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:44.814205: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:44.814548: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:44.814903: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:44.815490: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:44.815812: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:44.816170: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:44.816392: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:44.816981: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_________ test_causal_dilated_conv[layer_kwargs2-10-expected_output2] _________

layer_kwargs = {'dilation_rate': 2, 'filters': 1, 'kernel_initializer': 'ones', 'kernel_size': 3, ...}
input_length = 10
expected_output = array([[[ 0.],
        [ 1.],
        [ 2.],
        [ 4.],
        [ 6.],
        [ 9.],
        [12.],
        [15.],
        [18.],
        [21.]]], dtype=float32)

    @pytest.mark.skipif((K.backend() == 'cntk' and load_backend.dev.type() == 0),
                        reason='cntk only support dilated conv on GPU')
    @pytest.mark.parametrize(
        'layer_kwargs,input_length,expected_output',
        [
            # Causal
            ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'causal',
              'kernel_initializer': 'ones', 'use_bias': False},
             4, [[[0], [1], [3], [5]]]),
            # Non-causal
            ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'valid',
              'kernel_initializer': 'ones', 'use_bias': False},
             4, [[[1], [3], [5]]]),
            # Causal dilated with larger kernel size
            ({'filters': 1, 'kernel_size': 3, 'dilation_rate': 2, 'padding': 'causal',
              'kernel_initializer': 'ones', 'use_bias': False},
             10, np.float32([[[0], [1], [2], [4], [6], [9], [12], [15], [18], [21]]])),
        ]
    )
    def test_causal_dilated_conv(layer_kwargs, input_length, expected_output):
        input_data = np.reshape(np.arange(input_length, dtype='float32'),
                                (1, input_length, 1))
        layer_test(convolutional.Conv1D, input_data=input_data,
>                  kwargs=layer_kwargs, expected_output=expected_output)

convolutional_test.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'dilation_rate': 2, 'filters': 1, 'kernel_initializer': 'ones', 'kernel_size': 3, ...}
input_shape = (1, 10, 1), input_dtype = dtype('float32')
input_data = array([[[0.],
        [1.],
        [2.],
        [3.],
        [4.],
        [5.],
        [6.],
        [7.],
        [8.],
        [9.]]], dtype=float32)
expected_output = array([[[ 0.],
        [ 1.],
        [ 2.],
        [ 4.],
        [ 6.],
        [ 9.],
        [12.],
        [15.],
        [18.],
        [21.]]], dtype=float32)
expected_output_dtype = dtype('float32'), fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:44.935792: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:44.937868: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:44.939206: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:44.940504: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:44.941780: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:44.943065: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:44.944361: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:44.945678: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:44.947690: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:44.948836: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:44.950166: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:44.951007: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:44.952901: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
____________________________ test_conv_1d[valid-1] ____________________________

padding = 'valid', strides = 1

    @pytest.mark.parametrize(
        'padding,strides',
        [(padding, strides)
         for padding in _convolution_paddings
         for strides in [1, 2]
         if not (padding == 'same' and strides != 1)]
    )
    def test_conv_1d(padding, strides):
        batch_size = 2
        steps = 8
        input_dim = 2
        kernel_size = 3
        filters = 3
    
        layer_test(convolutional.Conv1D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': padding,
                           'strides': strides},
>                  input_shape=(batch_size, steps, input_dim))

convolutional_test.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'filters': 3, 'kernel_size': 3, 'padding': 'valid', 'strides': 1}
input_shape = (2, 8, 2), input_dtype = 'float32'
input_data = array([[[2.6524458 , 2.1666288 ],
        [3.0347238 , 4.404253  ],
        [2.8977666 , 0.14355032],
        [8.92407...
        [0.7133785 , 9.095851  ],
        [4.298175  , 4.244807  ],
        [9.140674  , 1.8020576 ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:45.102700: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:45.103311: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:45.103655: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:45.103999: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:45.104335: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:45.104698: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:45.105055: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:45.105400: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:45.105987: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:45.106306: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:45.106662: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:45.106881: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:45.107439: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
____________________________ test_conv_1d[valid-2] ____________________________

padding = 'valid', strides = 2

    @pytest.mark.parametrize(
        'padding,strides',
        [(padding, strides)
         for padding in _convolution_paddings
         for strides in [1, 2]
         if not (padding == 'same' and strides != 1)]
    )
    def test_conv_1d(padding, strides):
        batch_size = 2
        steps = 8
        input_dim = 2
        kernel_size = 3
        filters = 3
    
        layer_test(convolutional.Conv1D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': padding,
                           'strides': strides},
>                  input_shape=(batch_size, steps, input_dim))

convolutional_test.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'filters': 3, 'kernel_size': 3, 'padding': 'valid', 'strides': 2}
input_shape = (2, 8, 2), input_dtype = 'float32'
input_data = array([[[1.2430427 , 1.4775852 ],
        [1.4985832 , 2.2950027 ],
        [2.4066374 , 7.621974  ],
        [0.09813...
        [1.0956179 , 4.9766135 ],
        [2.131182  , 9.75903   ],
        [7.7803254 , 0.6255521 ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:45.233175: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:45.233760: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:45.234105: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:45.234446: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:45.234783: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:45.235122: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:45.235490: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:45.235838: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:45.236473: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:45.236801: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:45.237153: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:45.237371: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:45.237917: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
____________________________ test_conv_1d[same-1] _____________________________

padding = 'same', strides = 1

    @pytest.mark.parametrize(
        'padding,strides',
        [(padding, strides)
         for padding in _convolution_paddings
         for strides in [1, 2]
         if not (padding == 'same' and strides != 1)]
    )
    def test_conv_1d(padding, strides):
        batch_size = 2
        steps = 8
        input_dim = 2
        kernel_size = 3
        filters = 3
    
        layer_test(convolutional.Conv1D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': padding,
                           'strides': strides},
>                  input_shape=(batch_size, steps, input_dim))

convolutional_test.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'filters': 3, 'kernel_size': 3, 'padding': 'same', 'strides': 1}
input_shape = (2, 8, 2), input_dtype = 'float32'
input_data = array([[[1.2202654 , 9.900526  ],
        [1.7246066 , 5.799261  ],
        [1.2028472 , 6.85479   ],
        [6.46210...
        [3.4789262 , 8.856172  ],
        [3.625048  , 6.3483357 ],
        [4.9346476 , 9.80709   ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:45.338143: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:45.338734: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:45.339100: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:45.339444: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:45.339782: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:45.340130: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:45.340476: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:45.340820: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:45.341399: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:45.341720: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:45.342078: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:45.342303: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:45.342849: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
____________________________ test_conv_1d_dilation ____________________________

    @pytest.mark.skipif((K.backend() == 'cntk' and load_backend.dev.type() == 0),
                        reason='cntk only support dilated conv on GPU')
    def test_conv_1d_dilation():
        batch_size = 2
        steps = 8
        input_dim = 2
        kernel_size = 3
        filters = 3
        padding = _convolution_paddings[-1]
    
        layer_test(convolutional.Conv1D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': padding,
                           'dilation_rate': 2},
>                  input_shape=(batch_size, steps, input_dim))

convolutional_test.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'dilation_rate': 2, 'filters': 3, 'kernel_size': 3, 'padding': 'same'}
input_shape = (2, 8, 2), input_dtype = 'float32'
input_data = array([[[0.99890804, 0.9156452 ],
        [1.8609027 , 6.8754964 ],
        [5.278069  , 5.46938   ],
        [4.76979...
        [1.9347541 , 8.88892   ],
        [3.3417833 , 4.0069103 ],
        [1.6989813 , 1.135404  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:45.502404: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:45.502992: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:45.503335: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:45.503699: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:45.504044: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:45.504390: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:45.504733: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:45.505078: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:45.505657: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:45.505977: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:45.506338: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:45.506572: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:45.507124: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
______________________ test_convolution_2d_channels_last ______________________

    def test_convolution_2d_channels_last():
        num_samples = 2
        filters = 2
        stack_size = 3
        num_row = 7
        num_col = 6
        padding = 'valid'
        strides = (2, 2)
    
        layer_test(convolutional.Conv2D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'data_format': 'channels_last',
                           'activation': None,
                           'kernel_regularizer': 'l2',
                           'bias_regularizer': 'l2',
                           'activity_regularizer': 'l2',
                           'kernel_constraint': 'max_norm',
                           'bias_constraint': 'max_norm',
                           'strides': strides},
>                  input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv2D'>
kwargs = {'activation': None, 'activity_regularizer': 'l2', 'bias_constraint': 'max_norm', 'bias_regularizer': 'l2', ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[8.243745  , 1.6864482 , 1.4849583 ],
         [5.0317907 , 6.0045147 , 2.470516  ],
         [0.65410167, 6....9964 ],
         [4.5399213 , 1.4506664 , 3.9148567 ],
         [5.4788394 , 7.280737  , 2.9292765 ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:46.321169: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:46.321755: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:46.322098: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:46.322439: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:46.322774: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:46.323113: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:46.323455: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:46.323810: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:46.324392: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:46.324705: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:46.325060: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:46.325281: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:46.325821: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
________________________ test_convolution_2d_dilation _________________________

    @pytest.mark.skipif((K.backend() == 'cntk' and load_backend.dev.type() == 0),
                        reason='cntk only supports dilated conv on GPU')
    def test_convolution_2d_dilation():
        num_samples = 2
        filters = 2
        stack_size = 3
        kernel_size = (3, 2)
        num_row = 7
        num_col = 6
        padding = 'valid'
    
        layer_test(convolutional.Conv2D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': padding,
                           'dilation_rate': (2, 2)},
>                  input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv2D'>
kwargs = {'dilation_rate': (2, 2), 'filters': 2, 'kernel_size': (3, 2), 'padding': 'valid'}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[7.5934615 , 7.7091184 , 7.3040996 ],
         [8.919123  , 3.5232716 , 2.0326936 ],
         [6.3617764 , 3....80594],
         [2.8997302 , 7.1498256 , 4.9447083 ],
         [0.5128745 , 3.608944  , 0.43585798]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:46.416895: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:46.417489: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:46.417847: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:46.418191: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:46.418527: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:46.418908: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:46.419276: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:46.419643: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:46.420244: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:46.420558: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:46.420919: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:46.421150: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:46.421693: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[valid-1-1-1] _____________________

padding = 'valid', strides = 1, multiplier = 1, dilation_rate = 1

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': 1, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[9.953214  , 9.822261  , 5.6598644 ],
        [3.355215  , 8.37058   , 2.289989  ],
        [3.5393655 , 5.261...997657  ],
        [4.5684986 , 5.145511  , 7.2574363 ],
        [0.05072904, 4.3016205 , 9.989713  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:49.096190: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:49.096779: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:49.097124: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:49.097466: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:49.097801: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:49.098143: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:49.098488: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:49.098839: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:49.099433: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:49.099746: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:49.100103: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:49.100323: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:49.100868: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[valid-1-1-2] _____________________

padding = 'valid', strides = 1, multiplier = 1, dilation_rate = 2

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': 2, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[3.3027732 , 7.5484195 , 1.2927755 ],
        [5.474639  , 7.324031  , 0.20983069],
        [3.5933409 , 7.337...1454964 ],
        [6.2144885 , 6.4602733 , 6.31758   ],
        [4.0895724 , 3.2304113 , 7.7934785 ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:49.250366: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:49.250962: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:49.251317: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:49.251756: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:49.252186: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:49.252619: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:49.252997: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:49.253365: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:49.253943: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:49.254297: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:49.254741: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:49.255032: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:49.255646: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[valid-1-2-1] _____________________

padding = 'valid', strides = 1, multiplier = 2, dilation_rate = 1

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': 1, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[3.8084197 , 4.32559   , 9.502571  ],
        [8.916202  , 9.884686  , 2.812941  ],
        [8.441641  , 0.943...5459906 ],
        [2.2754548 , 9.244351  , 4.424557  ],
        [3.3558908 , 9.026905  , 0.767747  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:49.387732: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:49.388321: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:49.388665: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:49.389006: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:49.389342: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:49.389680: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:49.390022: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:49.390385: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:49.390969: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:49.391278: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:49.391633: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:49.391856: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:49.392393: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[valid-1-2-2] _____________________

padding = 'valid', strides = 1, multiplier = 2, dilation_rate = 2

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': 2, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[7.3392577 , 0.47520643, 0.7047967 ],
        [9.252235  , 3.3644483 , 1.0626335 ],
        [4.2037406 , 1.160...866288  ],
        [1.4161655 , 7.007581  , 7.218386  ],
        [8.776934  , 5.926124  , 7.431448  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:49.624356: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:49.624950: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:49.625294: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:49.625636: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:49.625973: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:49.626311: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:49.626655: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:49.627003: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:49.627620: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:49.627964: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:49.628356: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:49.628600: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:49.629172: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[valid-2-1-1] _____________________

padding = 'valid', strides = 2, multiplier = 1, dilation_rate = 1

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': 1, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[3.7958717 , 3.6297588 , 8.258618  ],
        [5.292221  , 5.866325  , 8.029153  ],
        [6.4701533 , 6.658...564179  ],
        [1.6306399 , 3.1624503 , 4.9454284 ],
        [1.4011446 , 5.2081423 , 6.277021  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:49.810263: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:49.810886: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:49.811240: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:49.811580: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:49.811919: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:49.812260: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:49.812603: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:49.812947: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:49.813531: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:49.813870: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:49.814229: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:49.814450: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:49.815004: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[valid-2-2-1] _____________________

padding = 'valid', strides = 2, multiplier = 2, dilation_rate = 1

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': 1, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[6.618989  , 4.9503164 , 4.676502  ],
        [5.62777   , 1.0767797 , 0.01306441],
        [9.980562  , 7.911...9614889 ],
        [2.6068423 , 2.395085  , 3.4762821 ],
        [4.999055  , 9.385162  , 1.5073894 ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:49.976823: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:49.977493: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:49.977840: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:49.978183: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:49.978517: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:49.978858: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:49.979201: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:49.979549: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:49.980152: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:49.980473: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:49.980842: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:49.981062: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:49.981617: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[same-1-1-1] ______________________

padding = 'same', strides = 1, multiplier = 1, dilation_rate = 1

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': 1, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[1.8434494 , 1.8329489 , 0.87156534],
        [6.3313675 , 1.2494216 , 2.0628605 ],
        [2.3775375 , 1.787...444173  ],
        [8.364704  , 4.35543   , 1.4259914 ],
        [1.7758734 , 2.7963579 , 6.5884275 ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:50.127244: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:50.127836: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:50.128198: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:50.128550: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:50.128887: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:50.129229: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:50.129572: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:50.129915: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:50.130497: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:50.130821: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:50.131178: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:50.131398: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:50.131942: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[same-1-1-2] ______________________

padding = 'same', strides = 1, multiplier = 1, dilation_rate = 2

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': 2, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[4.5899215 , 8.962262  , 5.5200534 ],
        [9.073202  , 7.185775  , 9.2282295 ],
        [7.42025   , 0.393...21264474],
        [2.9489517 , 9.92671   , 7.704313  ],
        [2.5985413 , 4.9312224 , 9.534921  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:50.308426: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:50.309029: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:50.309378: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:50.309721: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:50.310061: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:50.310400: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:50.310743: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:50.311094: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:50.311707: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:50.312025: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:50.312380: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:50.312601: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:50.313173: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[same-1-2-1] ______________________

padding = 'same', strides = 1, multiplier = 2, dilation_rate = 1

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': 1, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[8.326797  , 7.0075297 , 2.9788537 ],
        [5.83798   , 4.3387423 , 7.5253267 ],
        [1.0773329 , 7.796...1960855 ],
        [8.206384  , 3.704243  , 7.6032557 ],
        [2.580152  , 0.7050358 , 7.533264  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:50.429159: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:50.429747: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:50.430107: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:50.430464: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:50.430800: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:50.431144: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:50.431486: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:50.431829: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:50.432402: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:50.432711: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:50.433074: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:50.433305: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:50.433846: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[same-1-2-2] ______________________

padding = 'same', strides = 1, multiplier = 2, dilation_rate = 2

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': 2, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[4.627455  , 2.3138974 , 0.33360413],
        [6.2347198 , 6.8292623 , 4.7397847 ],
        [8.573902  , 2.518...8091583 ],
        [6.5589    , 6.636777  , 9.681228  ],
        [9.459648  , 5.8795695 , 5.9062643 ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:50.657848: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:50.658440: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:50.658785: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:50.659129: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:50.659487: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:50.659836: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:50.660185: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:50.660530: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:50.661108: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:50.661427: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:50.661780: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:50.662002: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:50.662551: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides0-1-dilation_rate0] ___________

padding = 'valid', strides = (1, 1), multiplier = 1, dilation_rate = (1, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (1, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[0.6140352 , 8.924928  , 6.0605636 ],
         [6.623818  , 9.950857  , 1.5499978 ],
         [0.5514108 , 1....612  ],
         [5.4910116 , 6.1763086 , 0.36438152],
         [1.354485  , 0.8908871 , 9.133266  ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:51.041883: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:51.042465: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:51.042808: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:51.043148: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:51.043484: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:51.043823: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:51.044166: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:51.044514: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:51.045106: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:51.045412: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:51.045763: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:51.045984: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:51.046521: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides1-1-dilation_rate1] ___________

padding = 'valid', strides = (1, 1), multiplier = 1, dilation_rate = (2, 2)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (2, 2), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[2.1648738 , 6.724077  , 6.006141  ],
         [1.3442663 , 6.938473  , 5.6721406 ],
         [5.6678195 , 2....9206 ],
         [1.7011582 , 7.4997973 , 6.3873215 ],
         [5.0065084 , 4.3103895 , 9.514322  ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:51.202445: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:51.203037: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:51.203405: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:51.203748: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:51.204091: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:51.204439: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:51.204784: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:51.205126: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:51.205697: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:51.206007: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:51.206359: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:51.206579: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:51.207138: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides2-1-dilation_rate2] ___________

padding = 'valid', strides = (1, 1), multiplier = 1, dilation_rate = (2, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (2, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[4.8112    , 0.29764923, 8.590676  ],
         [2.53039   , 0.5564346 , 1.2057879 ],
         [2.1029534 , 1....223  ],
         [0.7097603 , 0.92702657, 2.461546  ],
         [7.4932485 , 6.178197  , 9.037735  ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:51.361290: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:51.361886: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:51.362234: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:51.362577: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:51.362912: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:51.363254: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:51.363597: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:51.363946: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:51.364548: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:51.364857: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:51.365214: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:51.365436: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:51.365974: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides3-2-dilation_rate3] ___________

padding = 'valid', strides = (1, 1), multiplier = 2, dilation_rate = (1, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': (1, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[3.7014503 , 3.806453  , 2.5601356 ],
         [0.20545015, 4.488348  , 1.5284725 ],
         [6.254211  , 5....8734 ],
         [6.251042  , 8.944719  , 9.402312  ],
         [9.460535  , 4.9282007 , 8.878938  ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:51.494250: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:51.494848: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:51.495214: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:51.495561: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:51.495902: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:51.496251: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:51.496600: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:51.496949: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:51.497527: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:51.497848: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:51.498210: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:51.498435: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:51.498975: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides4-2-dilation_rate4] ___________

padding = 'valid', strides = (1, 1), multiplier = 2, dilation_rate = (1, 2)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': (1, 2), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[4.72253   , 0.49027798, 0.71456033],
         [1.471568  , 2.087515  , 4.3720393 ],
         [2.1738875 , 6....1767 ],
         [4.344549  , 1.5301008 , 5.4750824 ],
         [4.1234107 , 2.1639788 , 8.913903  ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:51.667100: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:51.667698: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:51.668047: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:51.668390: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:51.668746: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:51.669095: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:51.669445: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:51.669792: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:51.670386: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:51.670697: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:51.671050: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:51.671275: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:51.671825: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides5-1-dilation_rate5] ___________

padding = 'valid', strides = (2, 2), multiplier = 1, dilation_rate = (1, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (1, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[7.498052  , 1.6283023 , 8.7872505 ],
         [5.1103883 , 6.3487344 , 3.6924238 ],
         [1.6663191 , 4....8583 ],
         [6.5305653 , 8.410946  , 9.657074  ],
         [9.441561  , 7.0955443 , 7.333088  ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:51.900735: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:51.901337: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:51.901684: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:51.902027: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:51.902363: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:51.902705: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:51.903071: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:51.903423: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:51.903998: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:51.904320: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:51.904672: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:51.904893: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:51.905439: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides6-2-dilation_rate6] ___________

padding = 'valid', strides = (2, 2), multiplier = 2, dilation_rate = (1, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': (1, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[0.61164117, 6.620923  , 3.5497327 ],
         [4.690595  , 4.3224363 , 2.9612112 ],
         [4.5972567 , 4....72   ],
         [1.708324  , 1.216727  , 8.216536  ],
         [4.2138724 , 8.815111  , 1.4719417 ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:51.997778: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:51.998372: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:51.998718: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:51.999061: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:51.999400: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:51.999742: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:52.000085: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:52.000434: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:52.001022: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:52.001334: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:52.001688: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:52.001910: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:52.002484: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[same-strides7-1-dilation_rate7] ____________

padding = 'same', strides = (1, 1), multiplier = 1, dilation_rate = (1, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (1, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[6.5974565 , 3.955979  , 8.120761  ],
         [4.2638354 , 5.4450455 , 8.4415245 ],
         [3.624839  , 3....9424 ],
         [0.364351  , 7.0885715 , 2.920448  ],
         [3.2508588 , 6.6024923 , 4.788546  ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:52.156043: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:52.156653: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:52.157013: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:52.157359: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:52.157697: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:52.158039: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:52.158381: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:52.158722: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:52.159303: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:52.159629: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:52.159991: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:52.160212: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:52.160787: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[same-strides8-1-dilation_rate8] ____________

padding = 'same', strides = (1, 1), multiplier = 1, dilation_rate = (2, 2)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (2, 2), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[2.4926655 , 3.300769  , 6.480841  ],
         [0.68681103, 5.5817304 , 7.319673  ],
         [3.8969307 , 3....6063 ],
         [0.47881827, 7.855273  , 6.654484  ],
         [2.9238145 , 9.029066  , 9.077912  ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:52.289847: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:52.290450: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:52.290793: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:52.291153: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:52.291493: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:52.291840: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:52.292184: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:52.292532: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:52.293110: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:52.293428: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:52.293779: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:52.294017: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:52.294563: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[same-strides9-1-dilation_rate9] ____________

padding = 'same', strides = (1, 1), multiplier = 1, dilation_rate = (2, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (2, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[6.327731  , 8.633062  , 0.2439457 ],
         [4.726509  , 6.023601  , 7.986053  ],
         [3.9025598 , 0....6057 ],
         [8.288448  , 0.56747204, 0.15074705],
         [0.58601487, 2.3244627 , 1.0853897 ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:52.399996: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:52.400590: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:52.400936: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:52.401276: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:52.401611: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:52.401951: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:52.402296: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:52.402643: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:52.403239: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:52.403547: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:52.403904: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:52.404124: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:52.404668: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
__________ test_separable_conv_2d[same-strides10-2-dilation_rate10] ___________

padding = 'same', strides = (1, 1), multiplier = 2, dilation_rate = (1, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': (1, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[3.7468052 , 7.805204  , 4.654798  ],
         [8.058805  , 0.5131814 , 8.308619  ],
         [0.47112337, 9....6375 ],
         [5.283587  , 9.327414  , 3.587784  ],
         [9.369804  , 3.524695  , 7.541209  ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:52.513388: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:52.513987: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:52.514359: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:52.514706: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:52.515043: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:52.515386: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:52.515730: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:52.516073: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:52.516645: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:52.516959: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:52.517332: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:52.517554: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:52.518103: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
__________ test_separable_conv_2d[same-strides11-2-dilation_rate11] ___________

padding = 'same', strides = (1, 1), multiplier = 2, dilation_rate = (1, 2)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': (1, 2), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[0.6318558 , 2.7416391 , 3.20338   ],
         [9.211498  , 8.942306  , 8.785868  ],
         [5.8656807 , 0....9603 ],
         [4.014193  , 9.222381  , 2.8515441 ],
         [3.8697944 , 9.523583  , 2.9514694 ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:52.663885: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:52.664615: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:52.665051: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:52.665458: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:52.665805: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:52.666144: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:52.666489: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:52.666838: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:52.667437: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:52.667751: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:52.668108: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:52.668331: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:52.669677: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_convolution_3d[valid-strides0] _____________________

padding = 'valid', strides = (1, 1, 1)

    @pytest.mark.parametrize(
        'padding,strides',
        [(padding, strides)
         for padding in _convolution_paddings
         for strides in [(1, 1, 1), (2, 2, 2)]
         if not (padding == 'same' and strides != (1, 1, 1))]
    )
    def test_convolution_3d(padding, strides):
        num_samples = 2
        filters = 2
        stack_size = 3
    
        input_len_dim1 = 9
        input_len_dim2 = 8
        input_len_dim3 = 8
    
        layer_test(convolutional.Convolution3D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides},
                   input_shape=(num_samples,
                                input_len_dim1, input_len_dim2, input_len_dim3,
>                               stack_size))

convolutional_test.py:521: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv3D'>
kwargs = {'filters': 2, 'kernel_size': 3, 'padding': 'valid', 'strides': (1, 1, 1)}
input_shape = (2, 9, 8, 8, 3), input_dtype = 'float32'
input_data = array([[[[[6.33645892e-01, 9.79055977e+00, 2.77085686e+00],
          [8.89571667e+00, 5.12813950e+00, 7.30469036e+00]..., 8.96463394e+00, 9.36862564e+00],
          [5.70138788e+00, 9.84462738e-01, 5.32301950e+00]]]]],
      dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:57.966909: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:57.967492: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:57.967836: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:57.968178: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:57.968514: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:57.968889: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:57.969255: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:57.969628: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:57.970245: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:57.970558: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:57.970914: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:57.971134: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:57.971676: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_convolution_3d[valid-strides1] _____________________

padding = 'valid', strides = (2, 2, 2)

    @pytest.mark.parametrize(
        'padding,strides',
        [(padding, strides)
         for padding in _convolution_paddings
         for strides in [(1, 1, 1), (2, 2, 2)]
         if not (padding == 'same' and strides != (1, 1, 1))]
    )
    def test_convolution_3d(padding, strides):
        num_samples = 2
        filters = 2
        stack_size = 3
    
        input_len_dim1 = 9
        input_len_dim2 = 8
        input_len_dim3 = 8
    
        layer_test(convolutional.Convolution3D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides},
                   input_shape=(num_samples,
                                input_len_dim1, input_len_dim2, input_len_dim3,
>                               stack_size))

convolutional_test.py:521: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv3D'>
kwargs = {'filters': 2, 'kernel_size': 3, 'padding': 'valid', 'strides': (2, 2, 2)}
input_shape = (2, 9, 8, 8, 3), input_dtype = 'float32'
input_data = array([[[[[8.4169120e-01, 9.7501259e+00, 1.3132565e+00],
          [3.1207436e-01, 7.6086402e+00, 2.7574525e+00],
    ...7144079e+00, 9.0443497e+00, 8.6870632e+00],
          [1.2442126e+00, 2.9517910e-01, 9.3424492e+00]]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:58.090613: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:58.091207: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:58.091577: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:58.091927: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:58.092265: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:58.092610: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:58.092953: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:58.093297: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:58.093873: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:58.094193: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:58.094561: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:58.094782: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:58.095329: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_convolution_3d[same-strides2] ______________________

padding = 'same', strides = (1, 1, 1)

    @pytest.mark.parametrize(
        'padding,strides',
        [(padding, strides)
         for padding in _convolution_paddings
         for strides in [(1, 1, 1), (2, 2, 2)]
         if not (padding == 'same' and strides != (1, 1, 1))]
    )
    def test_convolution_3d(padding, strides):
        num_samples = 2
        filters = 2
        stack_size = 3
    
        input_len_dim1 = 9
        input_len_dim2 = 8
        input_len_dim3 = 8
    
        layer_test(convolutional.Convolution3D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides},
                   input_shape=(num_samples,
                                input_len_dim1, input_len_dim2, input_len_dim3,
>                               stack_size))

convolutional_test.py:521: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv3D'>
kwargs = {'filters': 2, 'kernel_size': 3, 'padding': 'same', 'strides': (1, 1, 1)}
input_shape = (2, 9, 8, 8, 3), input_dtype = 'float32'
input_data = array([[[[[8.09966   , 3.465277  , 5.1848903 ],
          [8.831773  , 6.1609907 , 8.759395  ],
          [7.2636847 ,...  ],
          [0.12535882, 4.5584626 , 8.057677  ],
          [5.2104416 , 5.6448455 , 7.0680795 ]]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:58.212258: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:58.212855: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:58.213209: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:58.213578: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:58.213929: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:58.214290: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:58.214646: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:58.215000: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:58.215578: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:58.215901: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:58.216257: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:58.216481: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:58.217028: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_convolution_3d_additional_args _____________________

    def test_convolution_3d_additional_args():
        num_samples = 2
        filters = 2
        stack_size = 3
        padding = 'valid'
        strides = (2, 2, 2)
    
        input_len_dim1 = 9
        input_len_dim2 = 8
        input_len_dim3 = 8
    
        layer_test(convolutional.Convolution3D,
                   kwargs={'filters': filters,
                           'kernel_size': (1, 2, 3),
                           'padding': padding,
                           'activation': None,
                           'kernel_regularizer': 'l2',
                           'bias_regularizer': 'l2',
                           'activity_regularizer': 'l2',
                           'kernel_constraint': 'max_norm',
                           'bias_constraint': 'max_norm',
                           'strides': strides},
                   input_shape=(num_samples,
                                input_len_dim1, input_len_dim2, input_len_dim3,
>                               stack_size))

convolutional_test.py:548: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv3D'>
kwargs = {'activation': None, 'activity_regularizer': 'l2', 'bias_constraint': 'max_norm', 'bias_regularizer': 'l2', ...}
input_shape = (2, 9, 8, 8, 3), input_dtype = 'float32'
input_data = array([[[[[2.9101959e-01, 5.1480756e+00, 7.6443724e-02],
          [9.6516600e+00, 2.4389241e+00, 5.3089476e+00],
    ...7044444e+00, 1.4433103e+00, 6.5309496e+00],
          [4.4170442e+00, 1.3184860e+00, 5.1210041e+00]]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:58.457809: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:58.458420: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:58.458769: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:58.459112: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:58.459452: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:58.459850: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:58.460200: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:58.460553: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:58.461163: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:58.461481: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:58.461843: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:58.462074: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:58.462651: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________________ test_conv_float64[input_shape0-Conv1D] ____________________

input_shape = (2, 4, 2)
conv_class = <class 'keras.layers.convolutional.Conv1D'>

    @pytest.mark.skipif((K.backend() == 'cntk'),
                        reason='CNTK does not support float64')
    @pytest.mark.parametrize(
        'input_shape,conv_class',
        [((2, 4, 2), convolutional.Conv1D),
         ((2, 4, 4, 2), convolutional.Conv2D),
         ((2, 4, 4, 4, 2), convolutional.Conv3D)]
    )
    def test_conv_float64(input_shape, conv_class):
        kernel_size = 3
        strides = 1
        filters = 3
        K.set_floatx('float64')
        layer_test(conv_class,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': 'valid',
                           'strides': strides},
>                  input_shape=input_shape)

convolutional_test.py:1138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'filters': 3, 'kernel_size': 3, 'padding': 'valid', 'strides': 1}
input_shape = (2, 4, 2), input_dtype = 'float64'
input_data = array([[[1.80725538, 6.68926063],
        [4.30729179, 2.42110575],
        [1.02154733, 8.20090249],
        [9.63398...3, 8.66627372],
        [7.9287661 , 6.34275851],
        [1.72419876, 4.53281621],
        [4.40053119, 4.40487004]]])
expected_output = None, expected_output_dtype = 'float64'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:13:03.769325: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:13:03.771412: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:13:03.772686: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:13:03.773957: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:13:03.775214: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:13:03.776480: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:13:03.777759: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:13:03.779054: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:13:03.781014: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:13:03.782127: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:13:03.783435: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:13:03.784251: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:13:03.786089: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________________ test_conv_float64[input_shape1-Conv2D] ____________________

input_shape = (2, 4, 4, 2)
conv_class = <class 'keras.layers.convolutional.Conv2D'>

    @pytest.mark.skipif((K.backend() == 'cntk'),
                        reason='CNTK does not support float64')
    @pytest.mark.parametrize(
        'input_shape,conv_class',
        [((2, 4, 2), convolutional.Conv1D),
         ((2, 4, 4, 2), convolutional.Conv2D),
         ((2, 4, 4, 4, 2), convolutional.Conv3D)]
    )
    def test_conv_float64(input_shape, conv_class):
        kernel_size = 3
        strides = 1
        filters = 3
        K.set_floatx('float64')
        layer_test(conv_class,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': 'valid',
                           'strides': strides},
>                  input_shape=input_shape)

convolutional_test.py:1138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv2D'>
kwargs = {'filters': 3, 'kernel_size': 3, 'padding': 'valid', 'strides': 1}
input_shape = (2, 4, 4, 2), input_dtype = 'float64'
input_data = array([[[[5.27762759e+00, 2.38951856e+00],
         [1.84176347e+00, 2.42628110e+00],
         [2.16909365e+00, 5.9576...51687995e+00, 7.36699770e+00],
         [9.17893029e+00, 1.42787735e+00],
         [4.96244536e+00, 1.87829303e+00]]]])
expected_output = None, expected_output_dtype = 'float64'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:13:03.921464: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:13:03.922072: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:13:03.922423: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:13:03.922772: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:13:03.923109: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:13:03.923454: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:13:03.923798: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:13:03.924142: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:13:03.924717: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:13:03.925035: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:13:03.925401: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:13:03.925630: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:13:03.926171: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________________ test_conv_float64[input_shape2-Conv3D] ____________________

input_shape = (2, 4, 4, 4, 2)
conv_class = <class 'keras.layers.convolutional.Conv3D'>

    @pytest.mark.skipif((K.backend() == 'cntk'),
                        reason='CNTK does not support float64')
    @pytest.mark.parametrize(
        'input_shape,conv_class',
        [((2, 4, 2), convolutional.Conv1D),
         ((2, 4, 4, 2), convolutional.Conv2D),
         ((2, 4, 4, 4, 2), convolutional.Conv3D)]
    )
    def test_conv_float64(input_shape, conv_class):
        kernel_size = 3
        strides = 1
        filters = 3
        K.set_floatx('float64')
        layer_test(conv_class,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': 'valid',
                           'strides': strides},
>                  input_shape=input_shape)

convolutional_test.py:1138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv3D'>
kwargs = {'filters': 3, 'kernel_size': 3, 'padding': 'valid', 'strides': 1}
input_shape = (2, 4, 4, 4, 2), input_dtype = 'float64'
input_data = array([[[[[9.92880201, 7.11308637],
          [9.56495402, 4.01871427],
          [6.05862826, 1.51433497],
          ...54473],
          [7.581656  , 2.66758329],
          [0.64690124, 6.45453906],
          [1.51516183, 3.09031295]]]]])
expected_output = None, expected_output_dtype = 'float64'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:13:04.029030: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:13:04.029667: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:13:04.030042: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:13:04.030415: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:13:04.030815: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:13:04.031257: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:13:04.031703: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:13:04.032143: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:13:04.032851: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:13:04.033250: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:13:04.033718: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:13:04.034007: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:13:04.034682: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
=========================== short test summary info ===========================
FAILED convolutional_test.py::test_causal_dilated_conv[layer_kwargs0-4-expected_output0]
FAILED convolutional_test.py::test_causal_dilated_conv[layer_kwargs1-4-expected_output1]
FAILED convolutional_test.py::test_causal_dilated_conv[layer_kwargs2-10-expected_output2]
FAILED convolutional_test.py::test_conv_1d[valid-1] - TypeError: zip argument...
FAILED convolutional_test.py::test_conv_1d[valid-2] - TypeError: zip argument...
FAILED convolutional_test.py::test_conv_1d[same-1] - TypeError: zip argument ...
FAILED convolutional_test.py::test_conv_1d_dilation - TypeError: zip argument...
FAILED convolutional_test.py::test_convolution_2d_channels_last - TypeError: ...
FAILED convolutional_test.py::test_convolution_2d_dilation - TypeError: zip a...
FAILED convolutional_test.py::test_separable_conv_1d[valid-1-1-1] - TypeError...
FAILED convolutional_test.py::test_separable_conv_1d[valid-1-1-2] - TypeError...
FAILED convolutional_test.py::test_separable_conv_1d[valid-1-2-1] - TypeError...
FAILED convolutional_test.py::test_separable_conv_1d[valid-1-2-2] - TypeError...
FAILED convolutional_test.py::test_separable_conv_1d[valid-2-1-1] - TypeError...
FAILED convolutional_test.py::test_separable_conv_1d[valid-2-2-1] - TypeError...
FAILED convolutional_test.py::test_separable_conv_1d[same-1-1-1] - TypeError:...
FAILED convolutional_test.py::test_separable_conv_1d[same-1-1-2] - TypeError:...
FAILED convolutional_test.py::test_separable_conv_1d[same-1-2-1] - TypeError:...
FAILED convolutional_test.py::test_separable_conv_1d[same-1-2-2] - TypeError:...
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides0-1-dilation_rate0]
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides1-1-dilation_rate1]
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides2-1-dilation_rate2]
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides3-2-dilation_rate3]
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides4-2-dilation_rate4]
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides5-1-dilation_rate5]
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides6-2-dilation_rate6]
FAILED convolutional_test.py::test_separable_conv_2d[same-strides7-1-dilation_rate7]
FAILED convolutional_test.py::test_separable_conv_2d[same-strides8-1-dilation_rate8]
FAILED convolutional_test.py::test_separable_conv_2d[same-strides9-1-dilation_rate9]
FAILED convolutional_test.py::test_separable_conv_2d[same-strides10-2-dilation_rate10]
FAILED convolutional_test.py::test_separable_conv_2d[same-strides11-2-dilation_rate11]
FAILED convolutional_test.py::test_convolution_3d[valid-strides0] - TypeError...
FAILED convolutional_test.py::test_convolution_3d[valid-strides1] - TypeError...
FAILED convolutional_test.py::test_convolution_3d[same-strides2] - TypeError:...
FAILED convolutional_test.py::test_convolution_3d_additional_args - TypeError...
FAILED convolutional_test.py::test_conv_float64[input_shape0-Conv1D] - TypeEr...
FAILED convolutional_test.py::test_conv_float64[input_shape1-Conv2D] - TypeEr...
FAILED convolutional_test.py::test_conv_float64[input_shape2-Conv3D] - TypeEr...
======================= 38 failed, 72 passed in 24.77s ========================
