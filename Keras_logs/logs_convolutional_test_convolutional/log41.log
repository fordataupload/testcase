2020-10-03 17:12:06.564641: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
============================= test session starts =============================
platform win32 -- Python 3.6.12, pytest-6.0.2, py-1.9.0, pluggy-0.13.1
rootdir: C:\Users\mutation\Desktop\testcase\tests\keras\layers
plugins: flaky-3.7.0
collected 110 items

convolutional_test.py FFFFFFFFFFFFF...........FFFFFFFFFFF.FFFFFFFFFFFFF. [ 45%]
..............FFFF.......................................FFF             [100%]

================================== FAILURES ===================================
_________ test_causal_dilated_conv[layer_kwargs0-4-expected_output0] __________

layer_kwargs = {'dilation_rate': 1, 'filters': 1, 'kernel_initializer': 'ones', 'kernel_size': 2, ...}
input_length = 4, expected_output = [[[0], [1], [3], [5]]]

    @pytest.mark.skipif((K.backend() == 'cntk' and load_backend.dev.type() == 0),
                        reason='cntk only support dilated conv on GPU')
    @pytest.mark.parametrize(
        'layer_kwargs,input_length,expected_output',
        [
            # Causal
            ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'causal',
              'kernel_initializer': 'ones', 'use_bias': False},
             4, [[[0], [1], [3], [5]]]),
            # Non-causal
            ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'valid',
              'kernel_initializer': 'ones', 'use_bias': False},
             4, [[[1], [3], [5]]]),
            # Causal dilated with larger kernel size
            ({'filters': 1, 'kernel_size': 3, 'dilation_rate': 2, 'padding': 'causal',
              'kernel_initializer': 'ones', 'use_bias': False},
             10, np.float32([[[0], [1], [2], [4], [6], [9], [12], [15], [18], [21]]])),
        ]
    )
    def test_causal_dilated_conv(layer_kwargs, input_length, expected_output):
        input_data = np.reshape(np.arange(input_length, dtype='float32'),
                                (1, input_length, 1))
        layer_test(convolutional.Conv1D, input_data=input_data,
>                  kwargs=layer_kwargs, expected_output=expected_output)

convolutional_test.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'dilation_rate': 1, 'filters': 1, 'kernel_initializer': 'ones', 'kernel_size': 2, ...}
input_shape = (1, 4, 1), input_dtype = dtype('float32')
input_data = array([[[0.],
        [1.],
        [2.],
        [3.]]], dtype=float32)
expected_output = [[[0], [1], [3], [5]]]
expected_output_dtype = dtype('float32'), fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
Using TensorFlow backend.
WARNING:tensorflow:From C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\resource_variable_ops.py:1630: calling BaseResourceVariable.__init__ (from tensorflow.python.ops.resource_variable_ops) with constraint is deprecated and will be removed in a future version.
Instructions for updating:
If using Keras pass *_constraint arguments to layers.
2020-10-03 17:12:09.647675: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library nvcuda.dll
2020-10-03 17:12:09.779950: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:09.781663: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:09.786596: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:09.791226: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:09.793144: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:09.799435: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:09.803725: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:09.816179: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:09.817221: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:09.817954: I tensorflow/core/platform/cpu_feature_guard.cc:142] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2
2020-10-03 17:12:09.832276: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:09.832885: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:09.833283: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:09.833676: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:09.834061: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:09.834449: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:09.834840: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:09.835225: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:09.836222: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:10.955854: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:10.957059: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:10.957784: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:10.960077: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
WARNING:tensorflow:From C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:422: The name tf.global_variables is deprecated. Please use tf.compat.v1.global_variables instead.

2020-10-03 17:12:11.439592: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:13.645628: W tensorflow/stream_executor/cuda/redzone_allocator.cc:312] Internal: Invoking ptxas not supported on Windows
Relying on driver to perform ptx compilation. This message will be only logged once.
2020-10-03 17:12:13.668848: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
------------------------------ Captured log call ------------------------------
WARNING  tensorflow:deprecation.py:506 From C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\resource_variable_ops.py:1630: calling BaseResourceVariable.__init__ (from tensorflow.python.ops.resource_variable_ops) with constraint is deprecated and will be removed in a future version.
Instructions for updating:
If using Keras pass *_constraint arguments to layers.
WARNING  tensorflow:module_wrapper.py:139 From C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:422: The name tf.global_variables is deprecated. Please use tf.compat.v1.global_variables instead.
_________ test_causal_dilated_conv[layer_kwargs1-4-expected_output1] __________

layer_kwargs = {'dilation_rate': 1, 'filters': 1, 'kernel_initializer': 'ones', 'kernel_size': 2, ...}
input_length = 4, expected_output = [[[1], [3], [5]]]

    @pytest.mark.skipif((K.backend() == 'cntk' and load_backend.dev.type() == 0),
                        reason='cntk only support dilated conv on GPU')
    @pytest.mark.parametrize(
        'layer_kwargs,input_length,expected_output',
        [
            # Causal
            ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'causal',
              'kernel_initializer': 'ones', 'use_bias': False},
             4, [[[0], [1], [3], [5]]]),
            # Non-causal
            ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'valid',
              'kernel_initializer': 'ones', 'use_bias': False},
             4, [[[1], [3], [5]]]),
            # Causal dilated with larger kernel size
            ({'filters': 1, 'kernel_size': 3, 'dilation_rate': 2, 'padding': 'causal',
              'kernel_initializer': 'ones', 'use_bias': False},
             10, np.float32([[[0], [1], [2], [4], [6], [9], [12], [15], [18], [21]]])),
        ]
    )
    def test_causal_dilated_conv(layer_kwargs, input_length, expected_output):
        input_data = np.reshape(np.arange(input_length, dtype='float32'),
                                (1, input_length, 1))
        layer_test(convolutional.Conv1D, input_data=input_data,
>                  kwargs=layer_kwargs, expected_output=expected_output)

convolutional_test.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'dilation_rate': 1, 'filters': 1, 'kernel_initializer': 'ones', 'kernel_size': 2, ...}
input_shape = (1, 4, 1), input_dtype = dtype('float32')
input_data = array([[[0.],
        [1.],
        [2.],
        [3.]]], dtype=float32)
expected_output = [[[1], [3], [5]]], expected_output_dtype = dtype('float32')
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:15.216724: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:15.217369: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:15.217747: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:15.218122: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:15.218522: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:15.218961: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:15.219397: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:15.219834: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:15.220480: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:15.220822: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:15.221213: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:15.221451: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:15.222045: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_________ test_causal_dilated_conv[layer_kwargs2-10-expected_output2] _________

layer_kwargs = {'dilation_rate': 2, 'filters': 1, 'kernel_initializer': 'ones', 'kernel_size': 3, ...}
input_length = 10
expected_output = array([[[ 0.],
        [ 1.],
        [ 2.],
        [ 4.],
        [ 6.],
        [ 9.],
        [12.],
        [15.],
        [18.],
        [21.]]], dtype=float32)

    @pytest.mark.skipif((K.backend() == 'cntk' and load_backend.dev.type() == 0),
                        reason='cntk only support dilated conv on GPU')
    @pytest.mark.parametrize(
        'layer_kwargs,input_length,expected_output',
        [
            # Causal
            ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'causal',
              'kernel_initializer': 'ones', 'use_bias': False},
             4, [[[0], [1], [3], [5]]]),
            # Non-causal
            ({'filters': 1, 'kernel_size': 2, 'dilation_rate': 1, 'padding': 'valid',
              'kernel_initializer': 'ones', 'use_bias': False},
             4, [[[1], [3], [5]]]),
            # Causal dilated with larger kernel size
            ({'filters': 1, 'kernel_size': 3, 'dilation_rate': 2, 'padding': 'causal',
              'kernel_initializer': 'ones', 'use_bias': False},
             10, np.float32([[[0], [1], [2], [4], [6], [9], [12], [15], [18], [21]]])),
        ]
    )
    def test_causal_dilated_conv(layer_kwargs, input_length, expected_output):
        input_data = np.reshape(np.arange(input_length, dtype='float32'),
                                (1, input_length, 1))
        layer_test(convolutional.Conv1D, input_data=input_data,
>                  kwargs=layer_kwargs, expected_output=expected_output)

convolutional_test.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'dilation_rate': 2, 'filters': 1, 'kernel_initializer': 'ones', 'kernel_size': 3, ...}
input_shape = (1, 10, 1), input_dtype = dtype('float32')
input_data = array([[[0.],
        [1.],
        [2.],
        [3.],
        [4.],
        [5.],
        [6.],
        [7.],
        [8.],
        [9.]]], dtype=float32)
expected_output = array([[[ 0.],
        [ 1.],
        [ 2.],
        [ 4.],
        [ 6.],
        [ 9.],
        [12.],
        [15.],
        [18.],
        [21.]]], dtype=float32)
expected_output_dtype = dtype('float32'), fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:15.349751: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:15.350332: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:15.350695: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:15.351035: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:15.351381: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:15.351729: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:15.352098: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:15.352467: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:15.353087: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:15.353473: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:15.353908: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:15.354179: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:15.354808: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
____________________________ test_conv_1d[valid-1] ____________________________

padding = 'valid', strides = 1

    @pytest.mark.parametrize(
        'padding,strides',
        [(padding, strides)
         for padding in _convolution_paddings
         for strides in [1, 2]
         if not (padding == 'same' and strides != 1)]
    )
    def test_conv_1d(padding, strides):
        batch_size = 2
        steps = 8
        input_dim = 2
        kernel_size = 3
        filters = 3
    
        layer_test(convolutional.Conv1D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': padding,
                           'strides': strides},
>                  input_shape=(batch_size, steps, input_dim))

convolutional_test.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'filters': 3, 'kernel_size': 3, 'padding': 'valid', 'strides': 1}
input_shape = (2, 8, 2), input_dtype = 'float32'
input_data = array([[[3.68512   , 9.908217  ],
        [0.2739213 , 5.1895204 ],
        [2.3803513 , 8.872337  ],
        [8.83747...
        [0.68168294, 2.2862172 ],
        [8.967864  , 7.3847094 ],
        [2.1547806 , 1.0659807 ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:15.495444: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:15.496027: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:15.496381: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:15.496721: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:15.497061: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:15.497407: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:15.497750: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:15.498106: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:15.498703: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:15.499018: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:15.499373: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:15.499596: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:15.500156: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
____________________________ test_conv_1d[valid-2] ____________________________

padding = 'valid', strides = 2

    @pytest.mark.parametrize(
        'padding,strides',
        [(padding, strides)
         for padding in _convolution_paddings
         for strides in [1, 2]
         if not (padding == 'same' and strides != 1)]
    )
    def test_conv_1d(padding, strides):
        batch_size = 2
        steps = 8
        input_dim = 2
        kernel_size = 3
        filters = 3
    
        layer_test(convolutional.Conv1D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': padding,
                           'strides': strides},
>                  input_shape=(batch_size, steps, input_dim))

convolutional_test.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'filters': 3, 'kernel_size': 3, 'padding': 'valid', 'strides': 2}
input_shape = (2, 8, 2), input_dtype = 'float32'
input_data = array([[[7.2571344 , 8.698232  ],
        [6.252255  , 3.5904672 ],
        [5.936096  , 3.2183836 ],
        [2.57857...
        [5.323601  , 9.501241  ],
        [6.9861336 , 3.8741412 ],
        [6.5830803 , 9.713414  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:15.645399: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:15.645992: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:15.646347: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:15.646694: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:15.647031: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:15.647374: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:15.647718: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:15.648062: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:15.648651: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:15.648977: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:15.649332: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:15.649556: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:15.650151: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
____________________________ test_conv_1d[same-1] _____________________________

padding = 'same', strides = 1

    @pytest.mark.parametrize(
        'padding,strides',
        [(padding, strides)
         for padding in _convolution_paddings
         for strides in [1, 2]
         if not (padding == 'same' and strides != 1)]
    )
    def test_conv_1d(padding, strides):
        batch_size = 2
        steps = 8
        input_dim = 2
        kernel_size = 3
        filters = 3
    
        layer_test(convolutional.Conv1D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': padding,
                           'strides': strides},
>                  input_shape=(batch_size, steps, input_dim))

convolutional_test.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'filters': 3, 'kernel_size': 3, 'padding': 'same', 'strides': 1}
input_shape = (2, 8, 2), input_dtype = 'float32'
input_data = array([[[0.8540002 , 9.676934  ],
        [6.4780235 , 2.3197045 ],
        [5.567449  , 5.3359885 ],
        [0.36532...
        [4.2868304 , 9.25022   ],
        [3.4467173 , 3.007906  ],
        [3.717378  , 2.5962107 ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:15.769566: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:15.770195: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:15.770544: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:15.770907: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:15.771251: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:15.771631: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:15.772000: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:15.772369: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:15.773004: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:15.773336: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:15.773716: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:15.773952: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:15.774594: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
____________________________ test_conv_1d_dilation ____________________________

    @pytest.mark.skipif((K.backend() == 'cntk' and load_backend.dev.type() == 0),
                        reason='cntk only support dilated conv on GPU')
    def test_conv_1d_dilation():
        batch_size = 2
        steps = 8
        input_dim = 2
        kernel_size = 3
        filters = 3
        padding = _convolution_paddings[-1]
    
        layer_test(convolutional.Conv1D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': padding,
                           'dilation_rate': 2},
>                  input_shape=(batch_size, steps, input_dim))

convolutional_test.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'dilation_rate': 2, 'filters': 3, 'kernel_size': 3, 'padding': 'same'}
input_shape = (2, 8, 2), input_dtype = 'float32'
input_data = array([[[6.0958786 , 0.90248644],
        [8.411516  , 9.247624  ],
        [3.4457715 , 9.953306  ],
        [3.97233...
        [5.107278  , 7.569817  ],
        [8.1681795 , 8.997983  ],
        [0.4334682 , 4.040604  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:15.978665: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:15.979255: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:15.979600: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:15.979943: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:15.980281: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:15.980620: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:15.980962: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:15.981310: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:15.981908: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:15.982225: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:15.982578: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:15.982798: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:15.983358: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_________________________ test_conv_1d_channels_first _________________________

    def test_conv_1d_channels_first():
        batch_size = 2
        steps = 8
        input_dim = 2
        kernel_size = 3
        filters = 3
    
        layer_test(convolutional.Conv1D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'data_format': 'channels_first'},
>                  input_shape=(batch_size, input_dim, steps))

convolutional_test.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'data_format': 'channels_first', 'filters': 3, 'kernel_size': 3}
input_shape = (2, 2, 8), input_dtype = 'float32'
input_data = array([[[7.059296  , 8.248937  , 5.042878  , 3.4355443 , 3.1867204 ,
         7.286514  , 0.75535434, 1.122162  ],
   ...734264 , 4.5972605 , 4.074733  , 2.9977798 , 2.874154  ,
         0.19301236, 3.4400342 , 4.83534   ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
                                            actual_output_shape):
            if expected_dim is not None:
>               assert expected_dim == actual_dim
E               AssertionError

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:105: AssertionError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:16.091800: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:16.092414: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:16.092796: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:16.093165: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:16.093508: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:16.093859: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:16.094203: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:16.094547: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:16.095131: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:16.095448: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:16.095813: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:16.096040: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:16.096599: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_convolution_2d[strides0-valid] _____________________

strides = (1, 1), padding = 'valid'

    @pytest.mark.parametrize(
        'strides,padding',
        [(strides, padding)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         if not (padding == 'same' and strides != (1, 1))]
    )
    def test_convolution_2d(strides, padding):
        num_samples = 2
        filters = 2
        stack_size = 3
        kernel_size = (3, 2)
        num_row = 7
        num_col = 6
    
        layer_test(convolutional.Conv2D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': padding,
                           'strides': strides,
                           'data_format': 'channels_first'},
>                  input_shape=(num_samples, stack_size, num_row, num_col))

convolutional_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv2D'>
kwargs = {'data_format': 'channels_first', 'filters': 2, 'kernel_size': (3, 2), 'padding': 'valid', ...}
input_shape = (2, 3, 7, 6), input_dtype = 'float32'
input_data = array([[[[0.31303796, 5.803474  , 1.8392254 , 3.7702613 , 5.472372  ,
          7.997787  ],
         [1.5890571 , 8.7...1105  ],
         [3.4766748 , 1.0254769 , 2.41837   , 2.8879921 , 3.4208295 ,
          6.82359   ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
                                            actual_output_shape):
            if expected_dim is not None:
>               assert expected_dim == actual_dim
E               AssertionError

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:105: AssertionError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:16.194260: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:16.194854: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:16.195255: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:16.195679: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:16.196098: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:16.196488: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:16.196859: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:16.197291: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:16.198011: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:16.198392: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:16.198770: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:16.199008: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:16.199669: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_convolution_2d[strides1-valid] _____________________

strides = (2, 2), padding = 'valid'

    @pytest.mark.parametrize(
        'strides,padding',
        [(strides, padding)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         if not (padding == 'same' and strides != (1, 1))]
    )
    def test_convolution_2d(strides, padding):
        num_samples = 2
        filters = 2
        stack_size = 3
        kernel_size = (3, 2)
        num_row = 7
        num_col = 6
    
        layer_test(convolutional.Conv2D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': padding,
                           'strides': strides,
                           'data_format': 'channels_first'},
>                  input_shape=(num_samples, stack_size, num_row, num_col))

convolutional_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv2D'>
kwargs = {'data_format': 'channels_first', 'filters': 2, 'kernel_size': (3, 2), 'padding': 'valid', ...}
input_shape = (2, 3, 7, 6), input_dtype = 'float32'
input_data = array([[[[8.369326  , 6.393531  , 8.54778   , 7.3522587 , 8.366422  ,
          7.4565473 ],
         [7.756668  , 5.5...22393 ],
         [0.1762083 , 2.2494042 , 9.883641  , 6.691328  , 9.743317  ,
          6.804677  ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
                                            actual_output_shape):
            if expected_dim is not None:
>               assert expected_dim == actual_dim
E               AssertionError

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:105: AssertionError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:16.320534: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:16.321200: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:16.321622: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:16.322056: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:16.322475: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:16.322899: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:16.323306: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:16.323680: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:16.324324: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:16.324664: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:16.325042: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:16.325277: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:16.325952: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_convolution_2d[strides2-same] ______________________

strides = (1, 1), padding = 'same'

    @pytest.mark.parametrize(
        'strides,padding',
        [(strides, padding)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         if not (padding == 'same' and strides != (1, 1))]
    )
    def test_convolution_2d(strides, padding):
        num_samples = 2
        filters = 2
        stack_size = 3
        kernel_size = (3, 2)
        num_row = 7
        num_col = 6
    
        layer_test(convolutional.Conv2D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': padding,
                           'strides': strides,
                           'data_format': 'channels_first'},
>                  input_shape=(num_samples, stack_size, num_row, num_col))

convolutional_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv2D'>
kwargs = {'data_format': 'channels_first', 'filters': 2, 'kernel_size': (3, 2), 'padding': 'same', ...}
input_shape = (2, 3, 7, 6), input_dtype = 'float32'
input_data = array([[[[4.4648347 , 5.5779815 , 5.5126653 , 5.4983964 , 6.515123  ,
          9.179759  ],
         [7.0443864 , 4.7...989762],
         [0.87377286, 8.9031105 , 8.912098  , 0.02098196, 0.8845515 ,
          4.3059125 ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
                                            actual_output_shape):
            if expected_dim is not None:
>               assert expected_dim == actual_dim
E               AssertionError

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:105: AssertionError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:16.445326: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:16.445926: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:16.446274: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:16.446615: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:16.447022: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:16.447448: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:16.447879: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:16.448271: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:16.448881: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:16.449204: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:16.449558: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:16.449778: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:16.450352: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
______________________ test_convolution_2d_channels_last ______________________

    def test_convolution_2d_channels_last():
        num_samples = 2
        filters = 2
        stack_size = 3
        num_row = 7
        num_col = 6
        padding = 'valid'
        strides = (2, 2)
    
        layer_test(convolutional.Conv2D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'data_format': 'channels_last',
                           'activation': None,
                           'kernel_regularizer': 'l2',
                           'bias_regularizer': 'l2',
                           'activity_regularizer': 'l2',
                           'kernel_constraint': 'max_norm',
                           'bias_constraint': 'max_norm',
                           'strides': strides},
>                  input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv2D'>
kwargs = {'activation': None, 'activity_regularizer': 'l2', 'bias_constraint': 'max_norm', 'bias_regularizer': 'l2', ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[9.6870575 , 6.786695  , 0.8198573 ],
         [2.390544  , 9.219367  , 7.503948  ],
         [3.5545337 , 3....4728 ],
         [0.9114228 , 3.1028914 , 8.981114  ],
         [6.9674816 , 9.113952  , 1.7259334 ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:16.550711: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:16.551311: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:16.551662: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:16.552026: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:16.552399: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:16.552772: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:16.553156: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:16.553527: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:16.554154: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:16.554489: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:16.554871: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:16.555110: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:16.555698: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
________________________ test_convolution_2d_dilation _________________________

    @pytest.mark.skipif((K.backend() == 'cntk' and load_backend.dev.type() == 0),
                        reason='cntk only supports dilated conv on GPU')
    def test_convolution_2d_dilation():
        num_samples = 2
        filters = 2
        stack_size = 3
        kernel_size = (3, 2)
        num_row = 7
        num_col = 6
        padding = 'valid'
    
        layer_test(convolutional.Conv2D,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': padding,
                           'dilation_rate': (2, 2)},
>                  input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv2D'>
kwargs = {'dilation_rate': (2, 2), 'filters': 2, 'kernel_size': (3, 2), 'padding': 'valid'}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[9.682799  , 8.294173  , 2.001985  ],
         [1.4883488 , 1.9169984 , 0.6772056 ],
         [2.141619  , 4....3327 ],
         [5.770292  , 8.198383  , 7.0665145 ],
         [5.198364  , 9.572847  , 5.3523393 ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:16.677881: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:16.678514: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:16.678882: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:16.679272: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:16.679630: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:16.679996: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:16.680361: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:16.680731: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:16.681400: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:16.681731: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:16.682107: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:16.682351: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:16.682911: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[valid-1-1-1] _____________________

padding = 'valid', strides = 1, multiplier = 1, dilation_rate = 1

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': 1, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[2.989263  , 2.8542116 , 7.611359  ],
        [1.6361613 , 7.0534277 , 4.166166  ],
        [8.211836  , 3.774...419389  ],
        [6.4329314 , 2.4134004 , 4.4835844 ],
        [5.594916  , 1.9188851 , 0.75923556]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:19.182232: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:19.182866: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:19.183240: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:19.183603: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:19.183967: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:19.184333: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:19.184701: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:19.185075: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:19.185706: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:19.186071: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:19.186449: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:19.186688: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:19.187269: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[valid-1-1-2] _____________________

padding = 'valid', strides = 1, multiplier = 1, dilation_rate = 2

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': 2, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[8.491648  , 4.773688  , 7.4283156 ],
        [9.955325  , 2.4234984 , 6.9947896 ],
        [6.98286   , 6.564...1564956 ],
        [3.863434  , 1.2609159 , 4.9064875 ],
        [7.9572387 , 9.036152  , 1.9391195 ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:19.326911: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:19.327499: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:19.327858: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:19.328209: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:19.328555: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:19.328908: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:19.329263: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:19.329630: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:19.330332: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:19.330739: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:19.331157: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:19.331384: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:19.331947: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[valid-1-2-1] _____________________

padding = 'valid', strides = 1, multiplier = 2, dilation_rate = 1

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': 1, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[6.5156446 , 2.00237   , 4.24133   ],
        [2.924027  , 7.107221  , 4.713388  ],
        [2.0948546 , 5.635...3686237 ],
        [1.2775071 , 1.7256123 , 2.5794752 ],
        [0.8464288 , 5.4227743 , 6.4791265 ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:19.511465: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:19.512097: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:19.512465: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:19.512832: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:19.513193: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:19.513555: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:19.513922: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:19.514294: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:19.514973: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:19.515365: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:19.515814: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:19.516095: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:19.516745: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[valid-1-2-2] _____________________

padding = 'valid', strides = 1, multiplier = 2, dilation_rate = 2

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': 2, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[6.976356  , 4.6767945 , 7.5811477 ],
        [1.3392752 , 6.692871  , 9.288222  ],
        [6.553916  , 1.585...224876  ],
        [9.323594  , 7.864459  , 6.4231033 ],
        [1.3649663 , 6.974561  , 7.456362  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:19.646789: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:19.647409: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:19.647779: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:19.648144: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:19.648507: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:19.648872: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:19.649243: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:19.649693: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:19.650414: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:19.650817: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:19.651193: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:19.651432: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:19.652028: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[valid-2-1-1] _____________________

padding = 'valid', strides = 2, multiplier = 1, dilation_rate = 1

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': 1, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[8.615882  , 6.751073  , 2.249772  ],
        [4.146876  , 6.816873  , 5.8920813 ],
        [1.5074564 , 4.598...1740917 ],
        [5.045878  , 7.079125  , 8.996328  ],
        [9.890562  , 2.8464818 , 4.892649  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:19.791286: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:19.791929: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:19.792306: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:19.792669: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:19.793033: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:19.793410: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:19.793785: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:19.794146: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:19.794798: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:19.795146: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:19.795534: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:19.795763: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:19.796350: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[valid-2-2-1] _____________________

padding = 'valid', strides = 2, multiplier = 2, dilation_rate = 1

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': 1, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[3.0292869 , 2.673618  , 6.684542  ],
        [8.106362  , 2.1538649 , 7.629838  ],
        [3.751566  , 8.777...04097   ],
        [4.6862073 , 3.4907508 , 6.412879  ],
        [2.6435964 , 7.309331  , 4.597424  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:19.957966: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:19.958608: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:19.958997: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:19.959380: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:19.959738: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:19.960138: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:19.960504: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:19.960874: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:19.961503: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:19.961857: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:19.962234: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:19.962468: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:19.963049: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[same-1-1-1] ______________________

padding = 'same', strides = 1, multiplier = 1, dilation_rate = 1

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': 1, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[3.106804  , 3.940169  , 0.03871765],
        [3.7775226 , 6.2160215 , 2.4389734 ],
        [5.7506485 , 0.443...151736  ],
        [1.267896  , 9.450847  , 8.867195  ],
        [6.022968  , 2.0292838 , 4.9862633 ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:20.191813: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:20.192407: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:20.192769: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:20.193134: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:20.193529: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:20.193945: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:20.194313: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:20.194685: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:20.195329: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:20.195643: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:20.196001: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:20.196302: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:20.196955: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[same-1-1-2] ______________________

padding = 'same', strides = 1, multiplier = 1, dilation_rate = 2

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': 2, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[9.517395  , 4.371412  , 3.5480385 ],
        [8.8130245 , 8.011324  , 1.2083526 ],
        [0.7782698 , 1.841...838777  ],
        [2.109681  , 8.800911  , 3.9382286 ],
        [5.1601067 , 5.9285483 , 8.363373  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:20.331320: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:20.331905: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:20.332256: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:20.332601: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:20.332941: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:20.333284: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:20.333635: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:20.333992: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:20.334590: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:20.334907: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:20.335268: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:20.335523: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:20.336194: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[same-1-2-1] ______________________

padding = 'same', strides = 1, multiplier = 2, dilation_rate = 1

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': 1, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[1.0648847 , 1.7146777 , 1.8171892 ],
        [4.9167495 , 3.9449825 , 4.0069566 ],
        [6.926802  , 4.136...386228  ],
        [5.4666023 , 6.101959  , 8.134671  ],
        [9.814588  , 5.56677   , 6.241078  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:20.442999: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:20.443592: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:20.443942: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:20.444285: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:20.444629: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:20.444974: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:20.445325: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:20.445677: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:20.446318: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:20.446671: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:20.447054: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:20.447292: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:20.447868: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_separable_conv_1d[same-1-2-2] ______________________

padding = 'same', strides = 1, multiplier = 2, dilation_rate = 2

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [1, 2]
         for multiplier in [1, 2]
         for dilation_rate in [1, 2]
         if (not (padding == 'same' and strides != 1)
             and not (dilation_rate != 1 and strides != 1)
             and not (dilation_rate != 1 and K.backend() == 'cntk'))]
    )
    def test_separable_conv_1d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides,
                           'depth_multiplier': multiplier,
                           'dilation_rate': dilation_rate},
>                  input_shape=(num_samples, num_step, stack_size))

convolutional_test.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': 2, 'filters': 6, 'kernel_size': 3, ...}
input_shape = (2, 9, 3), input_dtype = 'float32'
input_data = array([[[9.272339  , 3.2864969 , 8.622659  ],
        [1.7303514 , 9.153655  , 3.3987355 ],
        [2.7547932 , 4.737...9711475 ],
        [3.1711526 , 8.562973  , 6.4293733 ],
        [6.6882787 , 8.112627  , 6.543417  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:20.584613: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:20.585196: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:20.585582: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:20.585950: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:20.586314: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:20.586710: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:20.587082: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:20.587468: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:20.588092: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:20.588412: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:20.588770: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:20.588997: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:20.589547: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________________ test_separable_conv_1d_additional_args ____________________

    def test_separable_conv_1d_additional_args():
        num_samples = 2
        filters = 6
        stack_size = 3
        num_step = 9
        padding = 'valid'
        multiplier = 2
    
        layer_test(convolutional.SeparableConv1D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'data_format': 'channels_first',
                           'activation': None,
                           'depthwise_regularizer': 'l2',
                           'pointwise_regularizer': 'l2',
                           'bias_regularizer': 'l2',
                           'activity_regularizer': 'l2',
                           'pointwise_constraint': 'unit_norm',
                           'depthwise_constraint': 'unit_norm',
                           'strides': 1,
                           'use_bias': True,
                           'depth_multiplier': multiplier},
>                  input_shape=(num_samples, stack_size, num_step))

convolutional_test.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv1D'>
kwargs = {'activation': None, 'activity_regularizer': 'l2', 'bias_regularizer': 'l2', 'data_format': 'channels_first', ...}
input_shape = (2, 3, 9), input_dtype = 'float32'
input_data = array([[[5.26215   , 8.838701  , 7.44273   , 1.9993255 , 8.564719  ,
         7.54557   , 6.541749  , 7.7030416 , 9.16...63867  , 1.7676    , 5.366867  , 5.0613093 ,
         4.483958  , 9.515735  , 0.36301303, 6.401553  ]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
                                            actual_output_shape):
            if expected_dim is not None:
>               assert expected_dim == actual_dim
E               AssertionError

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:105: AssertionError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:20.714167: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:20.714754: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:20.715121: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:20.715465: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:20.715803: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:20.716146: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:20.716489: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:20.716832: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:20.717407: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:20.717722: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:20.718087: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:20.718306: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:20.718865: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides0-1-dilation_rate0] ___________

padding = 'valid', strides = (1, 1), multiplier = 1, dilation_rate = (1, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (1, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[2.7271464 , 0.59977126, 1.9792693 ],
         [7.500233  , 3.159473  , 5.0408096 ],
         [5.6244125 , 5....95   ],
         [5.202068  , 3.6669762 , 2.1919796 ],
         [2.3214622 , 6.4096293 , 3.2037926 ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:20.822490: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:20.823086: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:20.823445: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:20.823812: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:20.824168: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:20.824524: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:20.824873: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:20.825224: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:20.825804: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:20.826125: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:20.826485: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:20.826710: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:20.827283: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides1-1-dilation_rate1] ___________

padding = 'valid', strides = (1, 1), multiplier = 1, dilation_rate = (2, 2)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (2, 2), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[7.984475  , 0.68495226, 9.50643   ],
         [5.10459   , 5.5295887 , 5.211642  ],
         [8.6117115 , 5....961  ],
         [6.5702157 , 0.08908359, 3.7692525 ],
         [3.103322  , 1.1735803 , 5.4595804 ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:20.982135: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:20.982763: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:20.983132: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:20.983497: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:20.983858: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:20.984221: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:20.984588: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:20.984960: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:20.986385: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:20.987548: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:20.988863: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:20.989683: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:20.991388: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides2-1-dilation_rate2] ___________

padding = 'valid', strides = (1, 1), multiplier = 1, dilation_rate = (2, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (2, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[3.8555422e+00, 6.2489891e-01, 5.9565277e+00],
         [4.5208206e+00, 5.3306756e+00, 8.5232964e+00],
      ...4.4008551e+00, 7.8172674e+00, 6.7079296e+00],
         [5.3198380e+00, 6.8195925e+00, 5.0783544e+00]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:21.212503: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:21.213144: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:21.213519: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:21.213882: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:21.214218: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:21.214559: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:21.214906: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:21.215255: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:21.215849: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:21.216168: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:21.216523: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:21.216745: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:21.217300: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides3-2-dilation_rate3] ___________

padding = 'valid', strides = (1, 1), multiplier = 2, dilation_rate = (1, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': (1, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[8.51665306e+00, 8.28785515e+00, 7.65355730e+00],
         [5.28060150e+00, 7.35246611e+00, 7.62561655e+00],
...00, 3.46976042e+00, 1.48313439e+00],
         [5.49844456e+00, 2.26269555e+00, 1.23541504e-01]]]],
      dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:21.367743: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:21.368374: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:21.368767: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:21.369212: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:21.369644: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:21.370052: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:21.370434: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:21.370786: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:21.371390: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:21.371708: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:21.372069: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:21.372294: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:21.372852: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides4-2-dilation_rate4] ___________

padding = 'valid', strides = (1, 1), multiplier = 2, dilation_rate = (1, 2)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': (1, 2), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[0.37226158, 7.976651  , 5.3487983 ],
         [2.7906291 , 0.17415418, 1.5179907 ],
         [8.83383   , 0....3976 ],
         [0.55752826, 6.513361  , 1.7524296 ],
         [8.654477  , 2.393519  , 2.4923258 ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:21.530035: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:21.530682: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:21.531101: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:21.531527: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:21.531948: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:21.532333: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:21.532702: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:21.533074: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:21.533705: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:21.534039: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:21.534417: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:21.534653: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:21.535227: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides5-1-dilation_rate5] ___________

padding = 'valid', strides = (2, 2), multiplier = 1, dilation_rate = (1, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (1, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[2.0074468e+00, 2.1994936e+00, 3.1508896e-01],
         [4.1575913e+00, 9.8554630e+00, 1.2811660e+00],
      ...3.7412140e+00, 8.5974579e+00, 3.9276304e+00],
         [4.0482392e+00, 3.2473583e+00, 5.4484115e+00]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:21.688558: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:21.689201: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:21.689599: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:21.689981: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:21.690356: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:21.690735: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:21.691111: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:21.691509: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:21.692126: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:21.692458: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:21.692826: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:21.693057: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:21.693613: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[valid-strides6-2-dilation_rate6] ___________

padding = 'valid', strides = (2, 2), multiplier = 2, dilation_rate = (1, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': (1, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[6.9486108e+00, 8.1285887e+00, 7.2314782e+00],
         [5.4619598e+00, 5.8544173e+00, 7.4976568e+00],
      ...1.8466443e+00, 4.6195376e-01, 4.3140478e-02],
         [4.8308992e+00, 5.8545265e+00, 1.5839966e-01]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:21.789765: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:21.790484: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:21.790919: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:21.791353: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:21.791773: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:21.792163: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:21.792530: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:21.792903: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:21.793534: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:21.793871: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:21.794251: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:21.794488: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:21.795071: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[same-strides7-1-dilation_rate7] ____________

padding = 'same', strides = (1, 1), multiplier = 1, dilation_rate = (1, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (1, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[3.3696437 , 6.6253314 , 6.715437  ],
         [7.261302  , 5.7450223 , 8.881681  ],
         [1.156034  , 8....9067 ],
         [8.63946   , 1.968505  , 5.766898  ],
         [4.343561  , 6.5232635 , 0.0170282 ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:21.904413: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:21.905038: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:21.905409: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:21.905780: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:21.906140: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:21.906506: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:21.906877: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:21.907264: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:21.907894: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:21.908234: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:21.908613: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:21.908849: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:21.909490: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[same-strides8-1-dilation_rate8] ____________

padding = 'same', strides = (1, 1), multiplier = 1, dilation_rate = (2, 2)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (2, 2), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[7.808938  , 0.55087984, 7.095919  ],
         [8.237506  , 8.051754  , 9.06383   ],
         [4.540864  , 8....5554 ],
         [8.564106  , 8.320323  , 4.968752  ],
         [5.448387  , 4.6778646 , 9.97484   ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:22.129798: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:22.130541: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:22.130999: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:22.131456: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:22.131902: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:22.132274: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:22.132651: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:22.133050: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:22.133690: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:22.134045: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:22.134432: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:22.134670: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:22.135260: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________ test_separable_conv_2d[same-strides9-1-dilation_rate9] ____________

padding = 'same', strides = (1, 1), multiplier = 1, dilation_rate = (2, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 1, 'dilation_rate': (2, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[8.164331  , 3.1042142 , 0.10315587],
         [7.1248746 , 6.1881113 , 6.705789  ],
         [6.6063037 , 4....8583 ],
         [2.0016298 , 8.273507  , 7.2310357 ],
         [3.7004426 , 6.45305   , 6.2359633 ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:22.244423: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:22.245022: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:22.245384: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:22.245728: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:22.246077: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:22.246415: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:22.246758: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:22.247100: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:22.247681: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:22.247999: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:22.248368: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:22.248587: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:22.249141: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
__________ test_separable_conv_2d[same-strides10-2-dilation_rate10] ___________

padding = 'same', strides = (1, 1), multiplier = 2, dilation_rate = (1, 1)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': (1, 1), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[6.507416  , 8.969551  , 6.643496  ],
         [6.736448  , 4.065997  , 7.7954187 ],
         [6.7140484 , 5....25348],
         [2.606866  , 9.330698  , 1.2907556 ],
         [2.7539752 , 3.1132998 , 4.924536  ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:22.356793: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:22.357396: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:22.357744: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:22.358091: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:22.358446: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:22.358791: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:22.359148: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:22.359492: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:22.360070: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:22.360386: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:22.360738: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:22.360960: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:22.361525: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
__________ test_separable_conv_2d[same-strides11-2-dilation_rate11] ___________

padding = 'same', strides = (1, 1), multiplier = 2, dilation_rate = (1, 2)

    @pytest.mark.parametrize(
        'padding,strides,multiplier,dilation_rate',
        [(padding, strides, multiplier, dilation_rate)
         for padding in _convolution_paddings
         for strides in [(1, 1), (2, 2)]
         for multiplier in [1, 2]
         for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]
         if (not (padding == 'same' and strides != (1, 1))
             and not (dilation_rate != (1, 1) and strides != (1, 1))
             and not (dilation_rate != (1, 1) and multiplier == dilation_rate[0])
             and not (dilation_rate != (1, 1) and K.backend() == 'cntk'))]
    )
    def test_separable_conv_2d(padding, strides, multiplier, dilation_rate):
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
    
        layer_test(
            convolutional.SeparableConv2D,
            kwargs={'filters': filters,
                    'kernel_size': (3, 3),
                    'padding': padding,
                    'strides': strides,
                    'depth_multiplier': multiplier,
                    'dilation_rate': dilation_rate},
>           input_shape=(num_samples, num_row, num_col, stack_size))

convolutional_test.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'depth_multiplier': 2, 'dilation_rate': (1, 2), 'filters': 6, 'kernel_size': (3, 3), ...}
input_shape = (2, 7, 6, 3), input_dtype = 'float32'
input_data = array([[[[9.866173  , 8.488632  , 6.175274  ],
         [4.527233  , 3.575626  , 5.7631974 ],
         [7.2902966 , 2....005  ],
         [3.4563265 , 8.102656  , 0.62774724],
         [4.898577  , 2.8415766 , 1.335275  ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:22.513550: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:22.514209: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:22.514580: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:22.514943: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:22.515311: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:22.515687: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:22.516063: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:22.516454: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:22.517087: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:22.517436: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:22.517825: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:22.518066: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:22.518675: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________________ test_separable_conv_2d_additional_args ____________________

    def test_separable_conv_2d_additional_args():
        num_samples = 2
        filters = 6
        stack_size = 3
        num_row = 7
        num_col = 6
        padding = 'valid'
        strides = (2, 2)
        multiplier = 2
    
        layer_test(convolutional.SeparableConv2D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'data_format': 'channels_first',
                           'activation': None,
                           'depthwise_regularizer': 'l2',
                           'pointwise_regularizer': 'l2',
                           'bias_regularizer': 'l2',
                           'activity_regularizer': 'l2',
                           'pointwise_constraint': 'unit_norm',
                           'depthwise_constraint': 'unit_norm',
                           'strides': strides,
                           'depth_multiplier': multiplier},
>                  input_shape=(num_samples, stack_size, num_row, num_col))

convolutional_test.py:423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.SeparableConv2D'>
kwargs = {'activation': None, 'activity_regularizer': 'l2', 'bias_regularizer': 'l2', 'data_format': 'channels_first', ...}
input_shape = (2, 3, 7, 6), input_dtype = 'float32'
input_data = array([[[[7.670388  , 8.356272  , 5.0516357 , 0.68655676, 3.2949748 ,
          9.015044  ],
         [9.831318  , 2.5...16232 ],
         [9.449246  , 3.2680051 , 3.9454293 , 9.544201  , 2.7332249 ,
          6.2284813 ]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
                                            actual_output_shape):
            if expected_dim is not None:
>               assert expected_dim == actual_dim
E               AssertionError

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:105: AssertionError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:22.620103: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:22.620706: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:22.621050: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:22.621393: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:22.621730: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:22.622069: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:22.622412: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:22.622761: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:22.623353: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:22.623675: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:22.624032: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:22.624253: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:22.624803: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_convolution_3d[valid-strides0] _____________________

padding = 'valid', strides = (1, 1, 1)

    @pytest.mark.parametrize(
        'padding,strides',
        [(padding, strides)
         for padding in _convolution_paddings
         for strides in [(1, 1, 1), (2, 2, 2)]
         if not (padding == 'same' and strides != (1, 1, 1))]
    )
    def test_convolution_3d(padding, strides):
        num_samples = 2
        filters = 2
        stack_size = 3
    
        input_len_dim1 = 9
        input_len_dim2 = 8
        input_len_dim3 = 8
    
        layer_test(convolutional.Convolution3D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides},
                   input_shape=(num_samples,
                                input_len_dim1, input_len_dim2, input_len_dim3,
>                               stack_size))

convolutional_test.py:521: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv3D'>
kwargs = {'filters': 2, 'kernel_size': 3, 'padding': 'valid', 'strides': (1, 1, 1)}
input_shape = (2, 9, 8, 8, 3), input_dtype = 'float32'
input_data = array([[[[[8.440439  , 7.135217  , 5.9616857 ],
          [0.8117467 , 9.802603  , 7.3384595 ],
          [7.024514  ,...5 ],
          [4.8637643 , 6.82704   , 3.9163167 ],
          [7.336541  , 2.8918214 , 6.2407475 ]]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:27.729146: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:27.729731: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:27.730094: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:27.730442: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:27.730784: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:27.731129: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:27.731485: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:27.731851: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:27.732434: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:27.732764: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:27.733131: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:27.733353: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:27.733895: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_convolution_3d[valid-strides1] _____________________

padding = 'valid', strides = (2, 2, 2)

    @pytest.mark.parametrize(
        'padding,strides',
        [(padding, strides)
         for padding in _convolution_paddings
         for strides in [(1, 1, 1), (2, 2, 2)]
         if not (padding == 'same' and strides != (1, 1, 1))]
    )
    def test_convolution_3d(padding, strides):
        num_samples = 2
        filters = 2
        stack_size = 3
    
        input_len_dim1 = 9
        input_len_dim2 = 8
        input_len_dim3 = 8
    
        layer_test(convolutional.Convolution3D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides},
                   input_shape=(num_samples,
                                input_len_dim1, input_len_dim2, input_len_dim3,
>                               stack_size))

convolutional_test.py:521: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv3D'>
kwargs = {'filters': 2, 'kernel_size': 3, 'padding': 'valid', 'strides': (2, 2, 2)}
input_shape = (2, 9, 8, 8, 3), input_dtype = 'float32'
input_data = array([[[[[8.736228  , 7.587495  , 4.75239   ],
          [0.86318743, 9.078607  , 6.2291603 ],
          [0.2980734 ,...  ],
          [8.656842  , 4.65947   , 1.6770072 ],
          [0.49404272, 9.787065  , 5.587989  ]]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:27.857779: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:27.858390: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:27.858739: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:27.859084: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:27.859427: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:27.859764: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:27.860106: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:27.860448: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:27.861022: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:27.861355: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:27.861716: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:27.861936: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:27.862479: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_convolution_3d[same-strides2] ______________________

padding = 'same', strides = (1, 1, 1)

    @pytest.mark.parametrize(
        'padding,strides',
        [(padding, strides)
         for padding in _convolution_paddings
         for strides in [(1, 1, 1), (2, 2, 2)]
         if not (padding == 'same' and strides != (1, 1, 1))]
    )
    def test_convolution_3d(padding, strides):
        num_samples = 2
        filters = 2
        stack_size = 3
    
        input_len_dim1 = 9
        input_len_dim2 = 8
        input_len_dim3 = 8
    
        layer_test(convolutional.Convolution3D,
                   kwargs={'filters': filters,
                           'kernel_size': 3,
                           'padding': padding,
                           'strides': strides},
                   input_shape=(num_samples,
                                input_len_dim1, input_len_dim2, input_len_dim3,
>                               stack_size))

convolutional_test.py:521: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv3D'>
kwargs = {'filters': 2, 'kernel_size': 3, 'padding': 'same', 'strides': (1, 1, 1)}
input_shape = (2, 9, 8, 8, 3), input_dtype = 'float32'
input_data = array([[[[[9.78547764e+00, 6.71826458e+00, 2.99293661e+00],
          [7.72446060e+00, 7.45819235e+00, 1.93395329e+00]..., 8.01041782e-01, 8.97038555e+00],
          [1.50678539e+00, 4.79333192e-01, 4.68215847e+00]]]]],
      dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:27.968405: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:27.968995: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:27.969342: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:27.969688: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:27.970024: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:27.970369: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:27.970712: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:27.971058: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:27.971653: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:27.971978: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:27.972333: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:27.972555: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:27.973102: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_____________________ test_convolution_3d_additional_args _____________________

    def test_convolution_3d_additional_args():
        num_samples = 2
        filters = 2
        stack_size = 3
        padding = 'valid'
        strides = (2, 2, 2)
    
        input_len_dim1 = 9
        input_len_dim2 = 8
        input_len_dim3 = 8
    
        layer_test(convolutional.Convolution3D,
                   kwargs={'filters': filters,
                           'kernel_size': (1, 2, 3),
                           'padding': padding,
                           'activation': None,
                           'kernel_regularizer': 'l2',
                           'bias_regularizer': 'l2',
                           'activity_regularizer': 'l2',
                           'kernel_constraint': 'max_norm',
                           'bias_constraint': 'max_norm',
                           'strides': strides},
                   input_shape=(num_samples,
                                input_len_dim1, input_len_dim2, input_len_dim3,
>                               stack_size))

convolutional_test.py:548: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv3D'>
kwargs = {'activation': None, 'activity_regularizer': 'l2', 'bias_constraint': 'max_norm', 'bias_regularizer': 'l2', ...}
input_shape = (2, 9, 8, 8, 3), input_dtype = 'float32'
input_data = array([[[[[9.8186058e-01, 3.0178971e+00, 6.5467799e-01],
          [9.5503759e+00, 1.7684708e+00, 6.1124201e+00],
    ...1095071e+00, 7.9117126e+00, 4.0240989e+00],
          [1.0279577e+00, 4.8702569e+00, 4.1184382e+00]]]]], dtype=float32)
expected_output = None, expected_output_dtype = 'float32'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:28.104400: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:28.104995: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:28.105350: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:28.105700: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:28.106035: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:28.106379: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:28.106721: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:28.107064: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:28.107642: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:28.107992: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:28.108395: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:28.108632: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:28.109196: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________________ test_conv_float64[input_shape0-Conv1D] ____________________

input_shape = (2, 4, 2)
conv_class = <class 'keras.layers.convolutional.Conv1D'>

    @pytest.mark.skipif((K.backend() == 'cntk'),
                        reason='CNTK does not support float64')
    @pytest.mark.parametrize(
        'input_shape,conv_class',
        [((2, 4, 2), convolutional.Conv1D),
         ((2, 4, 4, 2), convolutional.Conv2D),
         ((2, 4, 4, 4, 2), convolutional.Conv3D)]
    )
    def test_conv_float64(input_shape, conv_class):
        kernel_size = 3
        strides = 1
        filters = 3
        K.set_floatx('float64')
        layer_test(conv_class,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': 'valid',
                           'strides': strides},
>                  input_shape=input_shape)

convolutional_test.py:1138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv1D'>
kwargs = {'filters': 3, 'kernel_size': 3, 'padding': 'valid', 'strides': 1}
input_shape = (2, 4, 2), input_dtype = 'float64'
input_data = array([[[0.20598876, 2.47562063],
        [8.71181035, 1.72562954],
        [7.69347353, 5.54337818],
        [4.01315...5, 8.20903416],
        [6.03364079, 7.38325163],
        [9.38675824, 7.97663212],
        [5.13873492, 0.22637421]]])
expected_output = None, expected_output_dtype = 'float64'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:33.803477: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:33.804172: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:33.804519: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:33.804862: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:33.805197: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:33.805540: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:33.805884: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:33.806241: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:33.807003: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:33.807399: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:33.807758: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:33.807978: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:33.808559: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________________ test_conv_float64[input_shape1-Conv2D] ____________________

input_shape = (2, 4, 4, 2)
conv_class = <class 'keras.layers.convolutional.Conv2D'>

    @pytest.mark.skipif((K.backend() == 'cntk'),
                        reason='CNTK does not support float64')
    @pytest.mark.parametrize(
        'input_shape,conv_class',
        [((2, 4, 2), convolutional.Conv1D),
         ((2, 4, 4, 2), convolutional.Conv2D),
         ((2, 4, 4, 4, 2), convolutional.Conv3D)]
    )
    def test_conv_float64(input_shape, conv_class):
        kernel_size = 3
        strides = 1
        filters = 3
        K.set_floatx('float64')
        layer_test(conv_class,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': 'valid',
                           'strides': strides},
>                  input_shape=input_shape)

convolutional_test.py:1138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv2D'>
kwargs = {'filters': 3, 'kernel_size': 3, 'padding': 'valid', 'strides': 1}
input_shape = (2, 4, 4, 2), input_dtype = 'float64'
input_data = array([[[[7.18954301, 4.78684313],
         [0.35397645, 2.69208363],
         [0.58438391, 5.27802151],
         [8.5....52908502],
         [9.87798907, 4.47321883],
         [4.30422294, 5.69404149],
         [2.90148888, 5.54145421]]]])
expected_output = None, expected_output_dtype = 'float64'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:34.042352: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:34.042941: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:34.043286: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:34.043628: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:34.043964: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:34.044304: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:34.044648: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:34.044997: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:34.045595: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:34.045923: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:34.046281: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:34.046502: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:34.047047: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
___________________ test_conv_float64[input_shape2-Conv3D] ____________________

input_shape = (2, 4, 4, 4, 2)
conv_class = <class 'keras.layers.convolutional.Conv3D'>

    @pytest.mark.skipif((K.backend() == 'cntk'),
                        reason='CNTK does not support float64')
    @pytest.mark.parametrize(
        'input_shape,conv_class',
        [((2, 4, 2), convolutional.Conv1D),
         ((2, 4, 4, 2), convolutional.Conv2D),
         ((2, 4, 4, 4, 2), convolutional.Conv3D)]
    )
    def test_conv_float64(input_shape, conv_class):
        kernel_size = 3
        strides = 1
        filters = 3
        K.set_floatx('float64')
        layer_test(conv_class,
                   kwargs={'filters': filters,
                           'kernel_size': kernel_size,
                           'padding': 'valid',
                           'strides': strides},
>                  input_shape=input_shape)

convolutional_test.py:1138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

layer_cls = <class 'keras.layers.convolutional.Conv3D'>
kwargs = {'filters': 3, 'kernel_size': 3, 'padding': 'valid', 'strides': 1}
input_shape = (2, 4, 4, 4, 2), input_dtype = 'float64'
input_data = array([[[[[0.41996892, 9.87599597],
          [5.31738995, 6.21973508],
          [0.02929824, 7.15515716],
          ...95585],
          [6.73082553, 0.10973475],
          [3.20916049, 7.15697569],
          [8.01875856, 4.97759143]]]]])
expected_output = None, expected_output_dtype = 'float64'
fixed_batch_size = False

    def layer_test(layer_cls, kwargs={}, input_shape=None, input_dtype=None,
                   input_data=None, expected_output=None,
                   expected_output_dtype=None, fixed_batch_size=False):
        """Test routine for a layer with a single input tensor
        and single output tensor.
        """
        # generate input data
        if input_data is None:
            assert input_shape
            if not input_dtype:
                input_dtype = K.floatx()
            input_data_shape = list(input_shape)
            for i, e in enumerate(input_data_shape):
                if e is None:
                    input_data_shape[i] = np.random.randint(1, 4)
            input_data = (10 * np.random.random(input_data_shape))
            input_data = input_data.astype(input_dtype)
        else:
            if input_shape is None:
                input_shape = input_data.shape
            if input_dtype is None:
                input_dtype = input_data.dtype
        if expected_output_dtype is None:
            expected_output_dtype = input_dtype
    
        # instantiation
        layer = layer_cls(**kwargs)
    
        # test get_weights , set_weights at layer level
        weights = layer.get_weights()
        layer.set_weights(weights)
    
        expected_output_shape = layer.compute_output_shape(input_shape)
    
        # test in functional API
        if fixed_batch_size:
            x = Input(batch_shape=input_shape, dtype=input_dtype)
        else:
            x = Input(shape=input_shape[1:], dtype=input_dtype)
        y = layer(x)
        assert K.dtype(y) == expected_output_dtype
    
        # check with the functional API
        model = Model(x, y)
    
        actual_output = model.predict(input_data)
        actual_output_shape = actual_output.shape
        for expected_dim, actual_dim in zip(expected_output_shape,
>                                           actual_output_shape):
E                                           TypeError: zip argument #1 must support iteration

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\utils\test_utils.py:103: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-03 17:12:34.159634: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-03 17:12:34.160222: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-03 17:12:34.160567: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-03 17:12:34.160930: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-03 17:12:34.161273: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-03 17:12:34.161614: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-03 17:12:34.161966: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-03 17:12:34.162363: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-03 17:12:34.162982: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-03 17:12:34.163315: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-03 17:12:34.163670: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-03 17:12:34.163909: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-03 17:12:34.164457: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
=========================== short test summary info ===========================
FAILED convolutional_test.py::test_causal_dilated_conv[layer_kwargs0-4-expected_output0]
FAILED convolutional_test.py::test_causal_dilated_conv[layer_kwargs1-4-expected_output1]
FAILED convolutional_test.py::test_causal_dilated_conv[layer_kwargs2-10-expected_output2]
FAILED convolutional_test.py::test_conv_1d[valid-1] - TypeError: zip argument...
FAILED convolutional_test.py::test_conv_1d[valid-2] - TypeError: zip argument...
FAILED convolutional_test.py::test_conv_1d[same-1] - TypeError: zip argument ...
FAILED convolutional_test.py::test_conv_1d_dilation - TypeError: zip argument...
FAILED convolutional_test.py::test_conv_1d_channels_first - AssertionError
FAILED convolutional_test.py::test_convolution_2d[strides0-valid] - Assertion...
FAILED convolutional_test.py::test_convolution_2d[strides1-valid] - Assertion...
FAILED convolutional_test.py::test_convolution_2d[strides2-same] - AssertionE...
FAILED convolutional_test.py::test_convolution_2d_channels_last - TypeError: ...
FAILED convolutional_test.py::test_convolution_2d_dilation - TypeError: zip a...
FAILED convolutional_test.py::test_separable_conv_1d[valid-1-1-1] - TypeError...
FAILED convolutional_test.py::test_separable_conv_1d[valid-1-1-2] - TypeError...
FAILED convolutional_test.py::test_separable_conv_1d[valid-1-2-1] - TypeError...
FAILED convolutional_test.py::test_separable_conv_1d[valid-1-2-2] - TypeError...
FAILED convolutional_test.py::test_separable_conv_1d[valid-2-1-1] - TypeError...
FAILED convolutional_test.py::test_separable_conv_1d[valid-2-2-1] - TypeError...
FAILED convolutional_test.py::test_separable_conv_1d[same-1-1-1] - TypeError:...
FAILED convolutional_test.py::test_separable_conv_1d[same-1-1-2] - TypeError:...
FAILED convolutional_test.py::test_separable_conv_1d[same-1-2-1] - TypeError:...
FAILED convolutional_test.py::test_separable_conv_1d[same-1-2-2] - TypeError:...
FAILED convolutional_test.py::test_separable_conv_1d_additional_args - Assert...
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides0-1-dilation_rate0]
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides1-1-dilation_rate1]
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides2-1-dilation_rate2]
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides3-2-dilation_rate3]
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides4-2-dilation_rate4]
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides5-1-dilation_rate5]
FAILED convolutional_test.py::test_separable_conv_2d[valid-strides6-2-dilation_rate6]
FAILED convolutional_test.py::test_separable_conv_2d[same-strides7-1-dilation_rate7]
FAILED convolutional_test.py::test_separable_conv_2d[same-strides8-1-dilation_rate8]
FAILED convolutional_test.py::test_separable_conv_2d[same-strides9-1-dilation_rate9]
FAILED convolutional_test.py::test_separable_conv_2d[same-strides10-2-dilation_rate10]
FAILED convolutional_test.py::test_separable_conv_2d[same-strides11-2-dilation_rate11]
FAILED convolutional_test.py::test_separable_conv_2d_additional_args - Assert...
FAILED convolutional_test.py::test_convolution_3d[valid-strides0] - TypeError...
FAILED convolutional_test.py::test_convolution_3d[valid-strides1] - TypeError...
FAILED convolutional_test.py::test_convolution_3d[same-strides2] - TypeError:...
FAILED convolutional_test.py::test_convolution_3d_additional_args - TypeError...
FAILED convolutional_test.py::test_conv_float64[input_shape0-Conv1D] - TypeEr...
FAILED convolutional_test.py::test_conv_float64[input_shape1-Conv2D] - TypeEr...
FAILED convolutional_test.py::test_conv_float64[input_shape2-Conv3D] - TypeEr...
======================= 44 failed, 66 passed in 24.71s ========================
