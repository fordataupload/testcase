2020-10-03 14:55:45.321984: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
============================= test session starts =============================
platform win32 -- Python 3.6.12, pytest-6.0.2, py-1.9.0, pluggy-0.13.1
rootdir: C:\Users\mutation\Desktop\testcase\tests\keras
plugins: flaky-3.7.0
collected 111 items

losses_test.py ......F............F..................................... [ 51%]
..........................................FFFFFF......                   [100%]

================================== FAILURES ===================================
____ TestLossFunctions.test_objective_shapes_3d[categorical_crossentropy] _____

values = <tf.Variable 'Variable_1:0' shape=(5, 6, 7) dtype=float32>
dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
>       fn(values)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Variable 'Variable_1:0' shape=(5, 6, 7) dtype=float32>

    def inner(values):
>     _ = [_check_failed(v) for v in nest.flatten(values)
           if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x0000014336631630>

    _ = [_check_failed(v) for v in nest.flatten(values)
>        if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

v = <tf.Variable 'Variable_1:0' shape=(5, 6, 7) dtype=float32>

    def _check_failed(v):
      # NB. none of the _check_* functions could raise a ValueError, so
      # it is safe to use here.
>     raise ValueError(v)
E     ValueError: <tf.Variable 'Variable_1:0' shape=(5, 6, 7) dtype=float32>

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:248: ValueError

During handling of the above exception, another exception occurred:

self = <losses_test.TestLossFunctions object at 0x00000143362FA780>
loss_fn = <function categorical_crossentropy at 0x000001433603A400>

    @pytest.mark.parametrize('loss_fn', all_functions)
    def test_objective_shapes_3d(self, loss_fn):
        y_a = K.variable(np.random.random((5, 6, 7)))
        y_b = K.variable(np.random.random((5, 6, 7)))
>       objective_output = loss_fn(y_a, y_b)

losses_test.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:680: in categorical_crossentropy
    y_pred = K.constant(y_pred) if K.is_tensor(y_pred) else y_pred
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:649: in constant
    value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\keras\backend.py:929: in constant
    return constant_op.constant(value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:449: in make_tensor_proto
    _AssertCompatible(values, dtype)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Variable 'Variable_1:0' shape=(5, 6, 7) dtype=float32>
dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
        fn(values)
      except ValueError as e:
        [mismatch] = e.args
        if dtype is None:
          raise TypeError("List of Tensors when single Tensor expected")
        else:
          raise TypeError("Expected %s, got %s of type '%s' instead." %
>                         (dtype.name, repr(mismatch), type(mismatch).__name__))
E         TypeError: Expected float32, got <tf.Variable 'Variable_1:0' shape=(5, 6, 7) dtype=float32> of type 'ResourceVariable' instead.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:331: TypeError
____ TestLossFunctions.test_objective_shapes_2d[categorical_crossentropy] _____

values = <tf.Variable 'Variable_1:0' shape=(6, 7) dtype=float32>
dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
>       fn(values)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Variable 'Variable_1:0' shape=(6, 7) dtype=float32>

    def inner(values):
>     _ = [_check_failed(v) for v in nest.flatten(values)
           if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x000001437C71C160>

    _ = [_check_failed(v) for v in nest.flatten(values)
>        if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

v = <tf.Variable 'Variable_1:0' shape=(6, 7) dtype=float32>

    def _check_failed(v):
      # NB. none of the _check_* functions could raise a ValueError, so
      # it is safe to use here.
>     raise ValueError(v)
E     ValueError: <tf.Variable 'Variable_1:0' shape=(6, 7) dtype=float32>

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:248: ValueError

During handling of the above exception, another exception occurred:

self = <losses_test.TestLossFunctions object at 0x000001433630F198>
loss_fn = <function categorical_crossentropy at 0x000001433603A400>

    @pytest.mark.parametrize('loss_fn', all_functions)
    def test_objective_shapes_2d(self, loss_fn):
        y_a = K.variable(np.random.random((6, 7)))
        y_b = K.variable(np.random.random((6, 7)))
>       objective_output = loss_fn(y_a, y_b)

losses_test.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:680: in categorical_crossentropy
    y_pred = K.constant(y_pred) if K.is_tensor(y_pred) else y_pred
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:649: in constant
    value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\keras\backend.py:929: in constant
    return constant_op.constant(value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:449: in make_tensor_proto
    _AssertCompatible(values, dtype)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Variable 'Variable_1:0' shape=(6, 7) dtype=float32>
dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
        fn(values)
      except ValueError as e:
        [mismatch] = e.args
        if dtype is None:
          raise TypeError("List of Tensors when single Tensor expected")
        else:
          raise TypeError("Expected %s, got %s of type '%s' instead." %
>                         (dtype.name, repr(mismatch), type(mismatch).__name__))
E         TypeError: Expected float32, got <tf.Variable 'Variable_1:0' shape=(6, 7) dtype=float32> of type 'ResourceVariable' instead.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:331: TypeError
___________ TestCategoricalCrossentropy.test_all_correct_unweighted ___________

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>, dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
>       fn(values)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>

    def inner(values):
>     _ = [_check_failed(v) for v in nest.flatten(values)
           if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x000001437C63FA20>

    _ = [_check_failed(v) for v in nest.flatten(values)
>        if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

v = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>

    def _check_failed(v):
      # NB. none of the _check_* functions could raise a ValueError, so
      # it is safe to use here.
>     raise ValueError(v)
E     ValueError: Tensor("Const_1:0", shape=(3, 3), dtype=float32)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:248: ValueError

During handling of the above exception, another exception occurred:

self = <losses_test.TestCategoricalCrossentropy object at 0x000001433636B5C0>

    def test_all_correct_unweighted(self):
        y_true = K.constant([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
        y_pred = K.constant([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])
        cce_obj = losses.CategoricalCrossentropy()
>       loss = cce_obj(y_true, y_pred)

losses_test.py:624: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:680: in categorical_crossentropy
    y_pred = K.constant(y_pred) if K.is_tensor(y_pred) else y_pred
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:649: in constant
    value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\keras\backend.py:929: in constant
    return constant_op.constant(value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:449: in make_tensor_proto
    _AssertCompatible(values, dtype)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>, dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
        fn(values)
      except ValueError as e:
        [mismatch] = e.args
        if dtype is None:
          raise TypeError("List of Tensors when single Tensor expected")
        else:
          raise TypeError("Expected %s, got %s of type '%s' instead." %
>                         (dtype.name, repr(mismatch), type(mismatch).__name__))
E         TypeError: Expected float32, got <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32> of type 'Tensor' instead.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:331: TypeError
_________________ TestCategoricalCrossentropy.test_unweighted _________________

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>, dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
>       fn(values)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>

    def inner(values):
>     _ = [_check_failed(v) for v in nest.flatten(values)
           if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x000001437CB7D630>

    _ = [_check_failed(v) for v in nest.flatten(values)
>        if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

v = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>

    def _check_failed(v):
      # NB. none of the _check_* functions could raise a ValueError, so
      # it is safe to use here.
>     raise ValueError(v)
E     ValueError: Tensor("Const_1:0", shape=(3, 3), dtype=float32)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:248: ValueError

During handling of the above exception, another exception occurred:

self = <losses_test.TestCategoricalCrossentropy object at 0x000001437CB7D7B8>

    def test_unweighted(self):
        cce_obj = losses.CategoricalCrossentropy()
        y_true = K.constant([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
        y_pred = K.constant(
            [[.9, .05, .05], [.5, .89, .6], [.05, .01, .94]])
>       loss = cce_obj(y_true, y_pred)

losses_test.py:638: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:680: in categorical_crossentropy
    y_pred = K.constant(y_pred) if K.is_tensor(y_pred) else y_pred
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:649: in constant
    value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\keras\backend.py:929: in constant
    return constant_op.constant(value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:449: in make_tensor_proto
    _AssertCompatible(values, dtype)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>, dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
        fn(values)
      except ValueError as e:
        [mismatch] = e.args
        if dtype is None:
          raise TypeError("List of Tensors when single Tensor expected")
        else:
          raise TypeError("Expected %s, got %s of type '%s' instead." %
>                         (dtype.name, repr(mismatch), type(mismatch).__name__))
E         TypeError: Expected float32, got <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32> of type 'Tensor' instead.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:331: TypeError
______________ TestCategoricalCrossentropy.test_scalar_weighted _______________

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>, dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
>       fn(values)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>

    def inner(values):
>     _ = [_check_failed(v) for v in nest.flatten(values)
           if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x000001437C685780>

    _ = [_check_failed(v) for v in nest.flatten(values)
>        if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

v = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>

    def _check_failed(v):
      # NB. none of the _check_* functions could raise a ValueError, so
      # it is safe to use here.
>     raise ValueError(v)
E     ValueError: Tensor("Const_1:0", shape=(3, 3), dtype=float32)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:248: ValueError

During handling of the above exception, another exception occurred:

self = <losses_test.TestCategoricalCrossentropy object at 0x000001437C6855F8>

    def test_scalar_weighted(self):
        cce_obj = losses.CategoricalCrossentropy()
        y_true = K.constant([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
        y_pred = K.constant(
            [[.9, .05, .05], [.5, .89, .6], [.05, .01, .94]])
>       loss = cce_obj(y_true, y_pred, sample_weight=2.3)

losses_test.py:652: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:680: in categorical_crossentropy
    y_pred = K.constant(y_pred) if K.is_tensor(y_pred) else y_pred
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:649: in constant
    value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\keras\backend.py:929: in constant
    return constant_op.constant(value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:449: in make_tensor_proto
    _AssertCompatible(values, dtype)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>, dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
        fn(values)
      except ValueError as e:
        [mismatch] = e.args
        if dtype is None:
          raise TypeError("List of Tensors when single Tensor expected")
        else:
          raise TypeError("Expected %s, got %s of type '%s' instead." %
>                         (dtype.name, repr(mismatch), type(mismatch).__name__))
E         TypeError: Expected float32, got <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32> of type 'Tensor' instead.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:331: TypeError
______________ TestCategoricalCrossentropy.test_sample_weighted _______________

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>, dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
>       fn(values)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>

    def inner(values):
>     _ = [_check_failed(v) for v in nest.flatten(values)
           if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x000001437C9AF7F0>

    _ = [_check_failed(v) for v in nest.flatten(values)
>        if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

v = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>

    def _check_failed(v):
      # NB. none of the _check_* functions could raise a ValueError, so
      # it is safe to use here.
>     raise ValueError(v)
E     ValueError: Tensor("Const_1:0", shape=(3, 3), dtype=float32)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:248: ValueError

During handling of the above exception, another exception occurred:

self = <losses_test.TestCategoricalCrossentropy object at 0x000001437C9AF2B0>

    def test_sample_weighted(self):
        cce_obj = losses.CategoricalCrossentropy()
        y_true = K.constant([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
        y_pred = K.constant(
            [[.9, .05, .05], [.5, .89, .6], [.05, .01, .94]])
        sample_weight = K.constant([[1.2], [3.4], [5.6]], shape=(3, 1))
>       loss = cce_obj(y_true, y_pred, sample_weight=sample_weight)

losses_test.py:667: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:680: in categorical_crossentropy
    y_pred = K.constant(y_pred) if K.is_tensor(y_pred) else y_pred
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:649: in constant
    value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\keras\backend.py:929: in constant
    return constant_op.constant(value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:449: in make_tensor_proto
    _AssertCompatible(values, dtype)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>, dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
        fn(values)
      except ValueError as e:
        [mismatch] = e.args
        if dtype is None:
          raise TypeError("List of Tensors when single Tensor expected")
        else:
          raise TypeError("Expected %s, got %s of type '%s' instead." %
>                         (dtype.name, repr(mismatch), type(mismatch).__name__))
E         TypeError: Expected float32, got <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32> of type 'Tensor' instead.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:331: TypeError
________________ TestCategoricalCrossentropy.test_no_reduction ________________

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>, dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
>       fn(values)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>

    def inner(values):
>     _ = [_check_failed(v) for v in nest.flatten(values)
           if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x000001437C989588>

    _ = [_check_failed(v) for v in nest.flatten(values)
>        if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

v = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>

    def _check_failed(v):
      # NB. none of the _check_* functions could raise a ValueError, so
      # it is safe to use here.
>     raise ValueError(v)
E     ValueError: Tensor("Const_1:0", shape=(3, 3), dtype=float32)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:248: ValueError

During handling of the above exception, another exception occurred:

self = <losses_test.TestCategoricalCrossentropy object at 0x000001437C989278>

    def test_no_reduction(self):
        y_true = K.constant([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
        logits = K.constant([[8., 1., 1.], [0., 9., 1.], [2., 3., 5.]])
        cce_obj = losses.CategoricalCrossentropy(
            from_logits=True, reduction=losses_utils.Reduction.NONE)
>       loss = cce_obj(y_true, logits)

losses_test.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:680: in categorical_crossentropy
    y_pred = K.constant(y_pred) if K.is_tensor(y_pred) else y_pred
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:649: in constant
    value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\keras\backend.py:929: in constant
    return constant_op.constant(value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:449: in make_tensor_proto
    _AssertCompatible(values, dtype)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32>, dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
        fn(values)
      except ValueError as e:
        [mismatch] = e.args
        if dtype is None:
          raise TypeError("List of Tensors when single Tensor expected")
        else:
          raise TypeError("Expected %s, got %s of type '%s' instead." %
>                         (dtype.name, repr(mismatch), type(mismatch).__name__))
E         TypeError: Expected float32, got <tf.Tensor 'Const_1:0' shape=(3, 3) dtype=float32> of type 'Tensor' instead.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:331: TypeError
______________ TestCategoricalCrossentropy.test_label_smoothing _______________

values = <tf.Tensor 'Const:0' shape=(1, 3) dtype=float32>, dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
>       fn(values)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Tensor 'Const:0' shape=(1, 3) dtype=float32>

    def inner(values):
>     _ = [_check_failed(v) for v in nest.flatten(values)
           if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x000001437CDC69B0>

    _ = [_check_failed(v) for v in nest.flatten(values)
>        if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

v = <tf.Tensor 'Const:0' shape=(1, 3) dtype=float32>

    def _check_failed(v):
      # NB. none of the _check_* functions could raise a ValueError, so
      # it is safe to use here.
>     raise ValueError(v)
E     ValueError: Tensor("Const:0", shape=(1, 3), dtype=float32)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:248: ValueError

During handling of the above exception, another exception occurred:

self = <losses_test.TestCategoricalCrossentropy object at 0x000001437CDC65F8>

    def test_label_smoothing(self):
        logits = K.constant([[100.0, -100.0, -100.0]])
        y_true = K.constant([[1, 0, 0]])
        label_smoothing = 0.1
        # Softmax Cross Entropy Loss: -\sum_i p_i \log q_i
        # where for a softmax activation
        # \log q_i = x_i - \log \sum_j \exp x_j
        #          = x_i - x_max - \log \sum_j \exp (x_j - x_max)
        # For our activations, [100, -100, -100]
        # \log ( exp(0) + exp(-200) + exp(-200) ) = 0
        # so our log softmaxes become: [0, -200, -200]
        # Label smoothing: z' = z * (1 - L) + L/n
        #                  1  = 1 - L + L/n
        #                  0  = L/n
        # Applying the above two fns to the given input:
        # -0 * (1 - L + L/n) + 200 * L/n + 200 * L/n = 400 L/n
        cce_obj = losses.CategoricalCrossentropy(
            from_logits=True, label_smoothing=label_smoothing)
>       loss = cce_obj(y_true, logits)

losses_test.py:702: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:680: in categorical_crossentropy
    y_pred = K.constant(y_pred) if K.is_tensor(y_pred) else y_pred
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:649: in constant
    value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\keras\backend.py:929: in constant
    return constant_op.constant(value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:449: in make_tensor_proto
    _AssertCompatible(values, dtype)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = <tf.Tensor 'Const:0' shape=(1, 3) dtype=float32>, dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
        fn(values)
      except ValueError as e:
        [mismatch] = e.args
        if dtype is None:
          raise TypeError("List of Tensors when single Tensor expected")
        else:
          raise TypeError("Expected %s, got %s of type '%s' instead." %
>                         (dtype.name, repr(mismatch), type(mismatch).__name__))
E         TypeError: Expected float32, got <tf.Tensor 'Const:0' shape=(1, 3) dtype=float32> of type 'Tensor' instead.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:331: TypeError
=========================== short test summary info ===========================
FAILED losses_test.py::TestLossFunctions::test_objective_shapes_3d[categorical_crossentropy]
FAILED losses_test.py::TestLossFunctions::test_objective_shapes_2d[categorical_crossentropy]
FAILED losses_test.py::TestCategoricalCrossentropy::test_all_correct_unweighted
FAILED losses_test.py::TestCategoricalCrossentropy::test_unweighted - TypeErr...
FAILED losses_test.py::TestCategoricalCrossentropy::test_scalar_weighted - Ty...
FAILED losses_test.py::TestCategoricalCrossentropy::test_sample_weighted - Ty...
FAILED losses_test.py::TestCategoricalCrossentropy::test_no_reduction - TypeE...
FAILED losses_test.py::TestCategoricalCrossentropy::test_label_smoothing - Ty...
======================= 8 failed, 103 passed in 11.29s ========================
