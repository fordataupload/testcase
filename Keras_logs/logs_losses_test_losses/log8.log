2020-10-03 14:47:14.101904: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
============================= test session starts =============================
platform win32 -- Python 3.6.12, pytest-6.0.2, py-1.9.0, pluggy-0.13.1
rootdir: C:\Users\mutation\Desktop\testcase\tests\keras
plugins: flaky-3.7.0
collected 111 items

losses_test.py F............F.................FF...........F...........F [ 51%]
.FFFFFF.FF............................................                   [100%]

================================== FAILURES ===================================
_______ TestLossFunctions.test_objective_shapes_3d[mean_squared_error] ________

self = <losses_test.TestLossFunctions object at 0x000002C02FA121D0>
loss_fn = <function mean_squared_error at 0x000002C02F6C28C8>

    @pytest.mark.parametrize('loss_fn', all_functions)
    def test_objective_shapes_3d(self, loss_fn):
        y_a = K.variable(np.random.random((5, 6, 7)))
        y_b = K.variable(np.random.random((5, 6, 7)))
>       objective_output = loss_fn(y_a, y_b)

losses_test.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\variables.py:1079: in _run_op
    return tensor_oper(a.value(), *args, **kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
---------------------------- Captured stderr call -----------------------------
Using TensorFlow backend.
WARNING:tensorflow:From C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\resource_variable_ops.py:1630: calling BaseResourceVariable.__init__ (from tensorflow.python.ops.resource_variable_ops) with constraint is deprecated and will be removed in a future version.
Instructions for updating:
If using Keras pass *_constraint arguments to layers.
------------------------------ Captured log call ------------------------------
WARNING  tensorflow:deprecation.py:506 From C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\resource_variable_ops.py:1630: calling BaseResourceVariable.__init__ (from tensorflow.python.ops.resource_variable_ops) with constraint is deprecated and will be removed in a future version.
Instructions for updating:
If using Keras pass *_constraint arguments to layers.
_______ TestLossFunctions.test_objective_shapes_2d[mean_squared_error] ________

self = <losses_test.TestLossFunctions object at 0x000002C02FA5AAC8>
loss_fn = <function mean_squared_error at 0x000002C02F6C28C8>

    @pytest.mark.parametrize('loss_fn', all_functions)
    def test_objective_shapes_2d(self, loss_fn):
        y_a = K.variable(np.random.random((6, 7)))
        y_b = K.variable(np.random.random((6, 7)))
>       objective_output = loss_fn(y_a, y_b)

losses_test.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\variables.py:1079: in _run_op
    return tensor_oper(a.value(), *args, **kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
__________ TestLossFunctions.test_serializing_model_with_loss_class ___________

self = <losses_test.TestLossFunctions object at 0x000002C031877B70>
tmpdir = local('C:\\Users\\mutation\\AppData\\Local\\Temp\\pytest-of-mutation\\pytest-233\\test_serializing_model_with_lo0')

    def test_serializing_model_with_loss_class(self, tmpdir):
        model_filename = str(tmpdir / 'custom_loss.hdf')
    
        with custom_object_scope({'MSE_MAE_loss': MSE_MAE_loss}):
            loss = MSE_MAE_loss(0.3)
            inputs = keras.layers.Input((2,))
            outputs = keras.layers.Dense(1, name='model_output')(inputs)
            model = keras.models.Model(inputs, outputs)
>           model.compile(optimizer='sgd', loss={'model_output': loss})

losses_test.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:229: in compile
    self.total_loss = self._prepare_total_loss(masks)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:692: in _prepare_total_loss
    y_true, y_pred, sample_weight=sample_weight)
losses_test.py:48: in __call__
    return (self.mse_fraction * losses.mse(y_true, y_pred) +
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
_____________________ TestLossFunctions.test_loss_wrapper _____________________

self = <losses_test.TestLossFunctions object at 0x000002C031EE59B0>

    def test_loss_wrapper(self):
        loss_fn = losses.get('mse')
        mse_obj = losses.LossFunctionWrapper(loss_fn, name=loss_fn.__name__)
    
        assert mse_obj.name == 'mean_squared_error'
        assert (mse_obj.reduction == losses_utils.Reduction.SUM_OVER_BATCH_SIZE)
    
        y_true = K.constant([[1., 9.], [2., 5.]])
        y_pred = K.constant([[4., 8.], [12., 3.]])
        sample_weight = K.constant([1.2, 0.5])
>       loss = mse_obj(y_true, y_pred, sample_weight=sample_weight)

losses_test.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
_________ TestLossClasses.test_objective_shapes_3d[MeanSquaredError] __________

self = <losses_test.TestLossClasses object at 0x000002C02FA868D0>
cls = <class 'keras.losses.MeanSquaredError'>

    @pytest.mark.parametrize('cls', all_classes)
    def test_objective_shapes_3d(self, cls):
        y_a = K.variable(np.random.random((5, 6, 7)))
        y_b = K.variable(np.random.random((5, 6, 7)))
        sw = K.variable(np.random.random((5, 6)))
        obj_fn = cls(name='test')
>       objective_output = obj_fn(y_a, y_b, sample_weight=sw)

losses_test.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\variables.py:1079: in _run_op
    return tensor_oper(a.value(), *args, **kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
_________ TestLossClasses.test_objective_shapes_2d[MeanSquaredError] __________

self = <losses_test.TestLossClasses object at 0x000002C0386578D0>
cls = <class 'keras.losses.MeanSquaredError'>

    @pytest.mark.parametrize('cls', all_classes)
    def test_objective_shapes_2d(self, cls):
        y_a = K.variable(np.random.random((6, 7)))
        y_b = K.variable(np.random.random((6, 7)))
        sw = K.variable(np.random.random((6,)))
        obj_fn = cls(name='test')
>       objective_output = obj_fn(y_a, y_b, sample_weight=sw)

losses_test.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\variables.py:1079: in _run_op
    return tensor_oper(a.value(), *args, **kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
______________ TestMeanSquaredError.test_all_correct_unweighted _______________

self = <losses_test.TestMeanSquaredError object at 0x000002C031852828>

    def test_all_correct_unweighted(self):
        mse_obj = losses.MeanSquaredError()
        y_true = K.constant([4, 8, 12, 8, 1, 3], shape=(2, 3))
>       loss = mse_obj(y_true, y_true)

losses_test.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
____________________ TestMeanSquaredError.test_unweighted _____________________

self = <losses_test.TestMeanSquaredError object at 0x000002C031DB5320>

    def test_unweighted(self):
        mse_obj = losses.MeanSquaredError()
        y_true = K.constant([1, 9, 2, -5, -2, 6], shape=(2, 3))
        y_pred = K.constant([4, 8, 12, 8, 1, 3], shape=(2, 3))
>       loss = mse_obj(y_true, y_pred)

losses_test.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
__________________ TestMeanSquaredError.test_scalar_weighted __________________

self = <losses_test.TestMeanSquaredError object at 0x000002C031A93518>

    def test_scalar_weighted(self):
        mse_obj = losses.MeanSquaredError()
        y_true = K.constant([1, 9, 2, -5, -2, 6], shape=(2, 3))
        y_pred = K.constant([4, 8, 12, 8, 1, 3], shape=(2, 3))
>       loss = mse_obj(y_true, y_pred, sample_weight=2.3)

losses_test.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
__________________ TestMeanSquaredError.test_sample_weighted __________________

self = <losses_test.TestMeanSquaredError object at 0x000002C038651940>

    def test_sample_weighted(self):
        mse_obj = losses.MeanSquaredError()
        y_true = K.constant([1, 9, 2, -5, -2, 6], shape=(2, 3))
        y_pred = K.constant([4, 8, 12, 8, 1, 3], shape=(2, 3))
        sample_weight = K.constant([1.2, 3.4], shape=(2, 1))
>       loss = mse_obj(y_true, y_pred, sample_weight=sample_weight)

losses_test.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
_________________ TestMeanSquaredError.test_timestep_weighted _________________

self = <losses_test.TestMeanSquaredError object at 0x000002C031B93438>

    def test_timestep_weighted(self):
        mse_obj = losses.MeanSquaredError()
        y_true = K.constant([1, 9, 2, -5, -2, 6], shape=(2, 3, 1))
        y_pred = K.constant([4, 8, 12, 8, 1, 3], shape=(2, 3, 1))
        sample_weight = K.constant([3, 6, 5, 0, 4, 2], shape=(2, 3))
>       loss = mse_obj(y_true, y_pred, sample_weight=sample_weight)

losses_test.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
___________________ TestMeanSquaredError.test_zero_weighted ___________________

self = <losses_test.TestMeanSquaredError object at 0x000002C031E5D6A0>

    def test_zero_weighted(self):
        mse_obj = losses.MeanSquaredError()
        y_true = K.constant([1, 9, 2, -5, -2, 6], shape=(2, 3))
        y_pred = K.constant([4, 8, 12, 8, 1, 3], shape=(2, 3))
>       loss = mse_obj(y_true, y_pred, sample_weight=0)

losses_test.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
___________________ TestMeanSquaredError.test_no_reduction ____________________

self = <losses_test.TestMeanSquaredError object at 0x000002C03234E518>

    def test_no_reduction(self):
        mse_obj = losses.MeanSquaredError(
            reduction=losses_utils.Reduction.NONE)
        y_true = K.constant([1, 9, 2, -5, -2, 6], shape=(2, 3))
        y_pred = K.constant([4, 8, 12, 8, 1, 3], shape=(2, 3))
>       loss = mse_obj(y_true, y_pred, sample_weight=2.3)

losses_test.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
___________________ TestMeanSquaredError.test_sum_reduction ___________________

self = <losses_test.TestMeanSquaredError object at 0x000002C03187E908>

    def test_sum_reduction(self):
        mse_obj = losses.MeanSquaredError(
            reduction=losses_utils.Reduction.SUM)
        y_true = K.constant([1, 9, 2, -5, -2, 6], shape=(2, 3))
        y_pred = K.constant([4, 8, 12, 8, 1, 3], shape=(2, 3))
>       loss = mse_obj(y_true, y_pred, sample_weight=2.3)

losses_test.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:71: in __call__
    losses = self.call(y_true, y_pred)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:132: in call
    return self.fn(y_true, y_pred, **self._fn_kwargs)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\losses.py:606: in mean_squared_error
    return K.mean(K.square(y_pred - y_true), axis=-1)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:903: in binary_op_wrapper
    y, dtype_hint=x.dtype.base_dtype, name="y")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = None, shape = None, verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
=========================== short test summary info ===========================
FAILED losses_test.py::TestLossFunctions::test_objective_shapes_3d[mean_squared_error]
FAILED losses_test.py::TestLossFunctions::test_objective_shapes_2d[mean_squared_error]
FAILED losses_test.py::TestLossFunctions::test_serializing_model_with_loss_class
FAILED losses_test.py::TestLossFunctions::test_loss_wrapper - ValueError: Non...
FAILED losses_test.py::TestLossClasses::test_objective_shapes_3d[MeanSquaredError]
FAILED losses_test.py::TestLossClasses::test_objective_shapes_2d[MeanSquaredError]
FAILED losses_test.py::TestMeanSquaredError::test_all_correct_unweighted - Va...
FAILED losses_test.py::TestMeanSquaredError::test_unweighted - ValueError: No...
FAILED losses_test.py::TestMeanSquaredError::test_scalar_weighted - ValueErro...
FAILED losses_test.py::TestMeanSquaredError::test_sample_weighted - ValueErro...
FAILED losses_test.py::TestMeanSquaredError::test_timestep_weighted - ValueEr...
FAILED losses_test.py::TestMeanSquaredError::test_zero_weighted - ValueError:...
FAILED losses_test.py::TestMeanSquaredError::test_no_reduction - ValueError: ...
FAILED losses_test.py::TestMeanSquaredError::test_sum_reduction - ValueError:...
======================= 14 failed, 97 passed in 11.76s ========================
