2020-10-05 15:48:38.111380: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-05 15:48:40.689594: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library nvcuda.dll
2020-10-05 15:48:40.825848: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-05 15:48:40.827567: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-05 15:48:40.833093: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-05 15:48:40.838640: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-05 15:48:40.840402: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-05 15:48:40.846812: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-05 15:48:40.851135: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-05 15:48:40.863222: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-05 15:48:40.864206: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-05 15:48:40.864969: I tensorflow/core/platform/cpu_feature_guard.cc:142] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2
2020-10-05 15:48:40.879567: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-05 15:48:40.880124: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-05 15:48:40.880521: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-05 15:48:40.880871: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-05 15:48:40.881255: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-05 15:48:40.881612: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-05 15:48:40.881958: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-05 15:48:40.882306: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-05 15:48:40.883215: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-05 15:48:41.953870: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-05 15:48:41.954278: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-05 15:48:41.954500: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-05 15:48:41.955295: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
============================= test session starts =============================
platform win32 -- Python 3.6.12, pytest-6.0.2, py-1.9.0, pluggy-0.13.1
rootdir: C:\Users\mutation\Desktop\testcase\tests\keras\engine
plugins: flaky-3.7.0
collected 31 items

test_topology.py .........F............FF.....F.                         [100%]

================================== FAILURES ===================================
___________________________ test_multi_input_layer ____________________________

values = '', dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
>       fn(values)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = ''

    def inner(values):
>     _ = [_check_failed(v) for v in nest.flatten(values)
           if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x0000012A451C4240>

    _ = [_check_failed(v) for v in nest.flatten(values)
>        if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

v = ''

    def _check_failed(v):
      # NB. none of the _check_* functions could raise a ValueError, so
      # it is safe to use here.
>     raise ValueError(v)
E     ValueError

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:248: ValueError

During handling of the above exception, another exception occurred:

    def test_multi_input_layer():
        ####################################################
        # test multi-input layer
        a = Input(shape=(32,), name='input_a')
        b = Input(shape=(32,), name='input_b')
    
        dense = Dense(16, name='dense_1')
        a_2 = dense(a)
        b_2 = dense(b)
    
        merged = layers.concatenate([a_2, b_2], name='merge')
        assert merged._keras_shape == (None, 16 * 2)
        merge_layer, merge_node_index, merge_tensor_index = merged._keras_history
    
        assert merge_node_index == 0
        assert merge_tensor_index == 0
    
        assert len(merge_layer._inbound_nodes) == 1
        assert len(merge_layer._outbound_nodes) == 0
    
        assert len(merge_layer._inbound_nodes[0].input_tensors) == 2
        assert len(merge_layer._inbound_nodes[0].inbound_layers) == 2
    
        c = Dense(64, name='dense_2')(merged)
        d = Dense(5, name='dense_3')(c)
    
        model = Model(inputs=[a, b], outputs=[c, d], name='model')
        assert len(model.layers) == 6
        expected_shapes = [(None, 64), (None, 5)]
        assert model.compute_output_shape([(None, 32), (None, 32)]) == expected_shapes
        assert model.compute_mask([a, b], [None, None]) == [None, None]
        assert model.compute_output_shape([(None, 32), (None, 32)]) == expected_shapes
    
        # we don't check names of first 2 layers (inputs) because
        # ordering of same-level layers is not fixed
        expected_names = ['dense_1', 'merge', 'dense_2', 'dense_3']
        assert [l.name for l in model.layers][2:] == expected_names
        assert [l.name for l in model._input_layers] == ['input_a', 'input_b']
        assert [l.name for l in model._output_layers] == ['dense_2', 'dense_3']
    
        # actually run model
        fn = K.function(model.inputs, model.outputs)
        input_a_np = np.random.random((10, 32))
        input_b_np = np.random.random((10, 32))
        fn_outputs = fn([input_a_np, input_b_np])
        assert [x.shape for x in fn_outputs] == [(10, 64), (10, 5)]
    
        # test get_source_inputs
        source_inputs = get_source_inputs(c)
        assert source_inputs[0] is a
        assert source_inputs[1] is b
    
        # serialization / deserialization
        json_config = model.to_json()
        recreated_model = model_from_json(json_config)
>       recreated_model.compile('rmsprop', 'mse')

test_topology.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:229: in compile
    self.total_loss = self._prepare_total_loss(masks)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:702: in _prepare_total_loss
    total_loss += loss_weight * output_loss
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:924: in r_binary_op_wrapper
    x = ops.convert_to_tensor(x, dtype=y.dtype.base_dtype, name="x")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1184: in convert_to_tensor
    return convert_to_tensor_v2(value, dtype, preferred_dtype, name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:449: in make_tensor_proto
    _AssertCompatible(values, dtype)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = '', dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
        fn(values)
      except ValueError as e:
        [mismatch] = e.args
        if dtype is None:
          raise TypeError("List of Tensors when single Tensor expected")
        else:
          raise TypeError("Expected %s, got %s of type '%s' instead." %
>                         (dtype.name, repr(mismatch), type(mismatch).__name__))
E         TypeError: Expected float32, got '' of type 'str' instead.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:331: TypeError
---------------------------- Captured stderr call -----------------------------
2020-10-05 15:48:43.430348: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1618] Found device 0 with properties: 
name: GeForce RTX 2080 Ti major: 7 minor: 5 memoryClockRate(GHz): 1.65
pciBusID: 0000:73:00.0
2020-10-05 15:48:43.430936: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
2020-10-05 15:48:43.431280: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll
2020-10-05 15:48:43.431618: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cufft64_100.dll
2020-10-05 15:48:43.431953: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library curand64_100.dll
2020-10-05 15:48:43.432293: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusolver64_100.dll
2020-10-05 15:48:43.432634: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cusparse64_100.dll
2020-10-05 15:48:43.432983: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudnn64_7.dll
2020-10-05 15:48:43.433691: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0
2020-10-05 15:48:43.434083: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-10-05 15:48:43.434547: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1165]      0 
2020-10-05 15:48:43.434767: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1178] 0:   N 
2020-10-05 15:48:43.435276: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1304] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 8686 MB memory) -> physical GPU (device: 0, name: GeForce RTX 2080 Ti, pci bus id: 0000:73:00.0, compute capability: 7.5)
_______________________ test_recursion_with_bn_and_loss _______________________

values = '', dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
>       fn(values)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = ''

    def inner(values):
>     _ = [_check_failed(v) for v in nest.flatten(values)
           if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x0000012CB2614C18>

    _ = [_check_failed(v) for v in nest.flatten(values)
>        if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

v = ''

    def _check_failed(v):
      # NB. none of the _check_* functions could raise a ValueError, so
      # it is safe to use here.
>     raise ValueError(v)
E     ValueError

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:248: ValueError

During handling of the above exception, another exception occurred:

    def test_recursion_with_bn_and_loss():
        model1 = Sequential([
            layers.Dense(5, input_dim=5, activity_regularizer='l1'),
            layers.BatchNormalization(),
            layers.Dense(5),
        ])
    
        print('NEW MODEL')
        inputs = layers.Input(shape=(5,))
        outputs = model1(inputs)
        model2 = Model(inputs=inputs, outputs=outputs)
    
        assert len(model1.updates) == 2
        assert len(model2.updates) == 2
        assert len(model1.losses) == 1
        assert len(model2.losses) == 1, model2.layers[1]._per_input_losses
    
>       model1.compile(optimizer='sgd', loss='categorical_crossentropy')

test_topology.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:229: in compile
    self.total_loss = self._prepare_total_loss(masks)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:702: in _prepare_total_loss
    total_loss += loss_weight * output_loss
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:924: in r_binary_op_wrapper
    x = ops.convert_to_tensor(x, dtype=y.dtype.base_dtype, name="x")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1184: in convert_to_tensor
    return convert_to_tensor_v2(value, dtype, preferred_dtype, name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:449: in make_tensor_proto
    _AssertCompatible(values, dtype)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = '', dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
        fn(values)
      except ValueError as e:
        [mismatch] = e.args
        if dtype is None:
          raise TypeError("List of Tensors when single Tensor expected")
        else:
          raise TypeError("Expected %s, got %s of type '%s' instead." %
>                         (dtype.name, repr(mismatch), type(mismatch).__name__))
E         TypeError: Expected float32, got '' of type 'str' instead.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:331: TypeError
---------------------------- Captured stdout call -----------------------------
NEW MODEL
_____________ test_activity_regularization_with_model_composition _____________

values = '', dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
>       fn(values)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = ''

    def inner(values):
>     _ = [_check_failed(v) for v in nest.flatten(values)
           if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x0000012CB24C0E80>

    _ = [_check_failed(v) for v in nest.flatten(values)
>        if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

v = ''

    def _check_failed(v):
      # NB. none of the _check_* functions could raise a ValueError, so
      # it is safe to use here.
>     raise ValueError(v)
E     ValueError

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:248: ValueError

During handling of the above exception, another exception occurred:

    def test_activity_regularization_with_model_composition():
    
        def reg(x):
            return K.sum(x)
    
        net_a_input = Input((2,))
        net_a = net_a_input
        net_a = Dense(2, kernel_initializer='ones',
                      use_bias=False,
                      activity_regularizer=reg)(net_a)
        model_a = Model([net_a_input], [net_a])
    
        net_b_input = Input((2,))
        net_b = model_a(net_b_input)
        model_b = Model([net_b_input], [net_b])
    
>       model_b.compile(optimizer='sgd', loss=None)

test_topology.py:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:229: in compile
    self.total_loss = self._prepare_total_loss(masks)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:713: in _prepare_total_loss
    total_loss += loss_tensor
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:924: in r_binary_op_wrapper
    x = ops.convert_to_tensor(x, dtype=y.dtype.base_dtype, name="x")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1184: in convert_to_tensor
    return convert_to_tensor_v2(value, dtype, preferred_dtype, name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:449: in make_tensor_proto
    _AssertCompatible(values, dtype)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = '', dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
        fn(values)
      except ValueError as e:
        [mismatch] = e.args
        if dtype is None:
          raise TypeError("List of Tensors when single Tensor expected")
        else:
          raise TypeError("Expected %s, got %s of type '%s' instead." %
>                         (dtype.name, repr(mismatch), type(mismatch).__name__))
E         TypeError: Expected float32, got '' of type 'str' instead.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:331: TypeError
____________________ test_constant_initializer_with_numpy _____________________

values = '', dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
>       fn(values)

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = ''

    def inner(values):
>     _ = [_check_failed(v) for v in nest.flatten(values)
           if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x0000012CB2451390>

    _ = [_check_failed(v) for v in nest.flatten(values)
>        if not isinstance(v, expected_types)]

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

v = ''

    def _check_failed(v):
      # NB. none of the _check_* functions could raise a ValueError, so
      # it is safe to use here.
>     raise ValueError(v)
E     ValueError

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:248: ValueError

During handling of the above exception, another exception occurred:

    def test_constant_initializer_with_numpy():
        model = Sequential()
        model.add(Dense(2, input_shape=(3,),
                        kernel_initializer=Constant(1.)))
        model.add(Dense(3))
>       model.compile(loss='mse', optimizer='sgd', metrics=['acc'])

test_topology.py:833: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:229: in compile
    self.total_loss = self._prepare_total_loss(masks)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:702: in _prepare_total_loss
    total_loss += loss_weight * output_loss
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\ops\math_ops.py:924: in r_binary_op_wrapper
    x = ops.convert_to_tensor(x, dtype=y.dtype.base_dtype, name="x")
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1184: in convert_to_tensor
    return convert_to_tensor_v2(value, dtype, preferred_dtype, name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1242: in convert_to_tensor_v2
    as_ref=False)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\ops.py:1297: in internal_convert_to_tensor
    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:286: in _constant_tensor_conversion_function
    return constant(v, dtype=dtype, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:449: in make_tensor_proto
    _AssertCompatible(values, dtype)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = '', dtype = tf.float32

    def _AssertCompatible(values, dtype):
      if dtype is None:
        fn = _check_not_tensor
      else:
        try:
          fn = _TF_TO_IS_OK[dtype]
        except KeyError:
          # There isn't a specific fn, so we try to do the best possible.
          if dtype.is_integer:
            fn = _check_int
          elif dtype.is_floating:
            fn = _check_float
          elif dtype.is_complex:
            fn = _check_complex
          elif dtype.is_quantized:
            fn = _check_quantized
          else:
            fn = _check_not_tensor
    
      try:
        fn(values)
      except ValueError as e:
        [mismatch] = e.args
        if dtype is None:
          raise TypeError("List of Tensors when single Tensor expected")
        else:
          raise TypeError("Expected %s, got %s of type '%s' instead." %
>                         (dtype.name, repr(mismatch), type(mismatch).__name__))
E         TypeError: Expected float32, got '' of type 'str' instead.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:331: TypeError
============================== warnings summary ===============================
test_topology.py::test_recursion
  C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\network.py:190: UserWarning: Model inputs must come from `keras.layers.Input` (thus holding past layer metadata), they cannot be the output of a previous non-Input layer. Here, a tensor specified as input to your model was not an Input tensor, it was generated by layer dense_1.
  Note that input tensors are instantiated via `tensor = keras.layers.Input(shape)`.
  The tensor that caused the issue was: dense_1_12/BiasAdd:0
    str(x.name))

test_topology.py::test_activity_regularization_with_model_composition
  C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training_utils.py:819: UserWarning: Output model_1 missing from loss dictionary. We assume this was done on purpose. The fit and evaluate APIs will not be expecting any data to be passed to model_1.
    'be expecting any data to be passed to {0}.'.format(name))

-- Docs: https://docs.pytest.org/en/stable/warnings.html
=========================== short test summary info ===========================
FAILED test_topology.py::test_multi_input_layer - TypeError: Expected float32...
FAILED test_topology.py::test_recursion_with_bn_and_loss - TypeError: Expecte...
FAILED test_topology.py::test_activity_regularization_with_model_composition
FAILED test_topology.py::test_constant_initializer_with_numpy - TypeError: Ex...
================== 4 failed, 27 passed, 2 warnings in 7.90s ===================
