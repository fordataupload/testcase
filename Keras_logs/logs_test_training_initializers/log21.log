2020-10-04 19:56:45.692188: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
============================= test session starts =============================
platform win32 -- Python 3.6.12, pytest-6.0.2, py-1.9.0, pluggy-0.13.1
rootdir: C:\Users\mutation\Desktop\testcase\tests\keras\engine
plugins: flaky-3.7.0
collected 34 items

test_training.py ...FFFFsFF...FFFFFFFFF.F.F..F.....                      [100%]

================================== FAILURES ===================================
_____________________________ test_model_methods ______________________________

    @flaky(rerun_filter=lambda err, *args: issubclass(err[0], AssertionError))
    def test_model_methods():
>       model = get_model(num_outputs=2)

test_training.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_training.py:135: in get_model
    a_2 = Dense(4, name='dense_1')(a)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x000001719584F208>
shape = (3, 4), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
_____________________________ test_fit_generator ______________________________

    @flaky(rerun_filter=lambda err, *args: issubclass(err[0], AssertionError))
    def test_fit_generator():
>       model = get_model(num_outputs=2)

test_training.py:474: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_training.py:135: in get_model
    a_2 = Dense(4, name='dense_1')(a)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x00000171978196A0>
shape = (3, 4), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
__________________________ test_fit_generator_shape ___________________________

    def test_fit_generator_shape():
        # predict_generator output shape behavior should be consistent
        def expected_shape(batch_size, n_batches):
            return (batch_size * n_batches, 4), (batch_size * n_batches, 3)
    
>       model = get_model(num_outputs=2)

test_training.py:614: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_training.py:135: in get_model
    a_2 = Dense(4, name='dense_1')(a)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x0000017197532198>
shape = (3, 4), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
______________________ test_training_with_loss_instance _______________________

    def test_training_with_loss_instance():
        a = Input(shape=(3,), name='input_a')
        b = Input(shape=(3,), name='input_b')
    
        dense = Dense(4, name='dense')
>       c = dense(a)

test_training.py:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x00000171976AB470>
shape = (3, 4), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
___________________________ test_trainable_argument ___________________________

    def test_trainable_argument():
        x = np.random.random((5, 3))
        y = np.random.random((5, 2))
    
        model = Sequential()
>       model.add(Dense(2, input_dim=3, trainable=False))

test_training.py:784: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\sequential.py:166: in add
    layer(x)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x000001719759EDA0>
shape = (3, 2), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
__________________________ test_with_list_as_targets __________________________

    def test_with_list_as_targets():
        model = Sequential()
>       model.add(Dense(1, input_dim=3, trainable=False))

test_training.py:804: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\sequential.py:166: in add
    layer(x)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x00000171976B92B0>
shape = (3, 1), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
______________________ test_model_with_input_feed_tensor ______________________

    @pytest.mark.skipif(K.backend() != 'tensorflow',
                        reason='Requires TensorFlow backend')
    def test_model_with_input_feed_tensor():
        """We test building a model with a TF variable as input.
        We should be able to call fit, evaluate, predict,
        by only passing them data for the placeholder inputs
        in the model.
        """
        import tensorflow as tf
    
        input_a_np = np.random.random((10, 3))
        input_b_np = np.random.random((10, 3))
    
        output_a_np = np.random.random((10, 4))
        output_b_np = np.random.random((10, 3))
    
        a = Input(tensor=tf.Variable(input_a_np, dtype=tf.float32))
        b = Input(shape=(3,), name='input_b')
    
>       a_2 = Dense(4, name='dense_1')(a)

test_training.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x0000017197853DD8>
shape = (3, 4), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
________________________ test_model_with_partial_loss _________________________

    def test_model_with_partial_loss():
        a = Input(shape=(3,), name='input_a')
>       a_2 = Dense(4, name='dense_1')(a)

test_training.py:981: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x0000017197578BE0>
shape = (3, 4), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
________________________ test_model_with_external_loss ________________________

    @pytest.mark.skipif((K.backend() == 'cntk'),
                        reason='cntk does not support external loss yet')
    def test_model_with_external_loss():
        # None loss, only regularization loss.
        a = Input(shape=(3,), name='input_a')
        a_2 = Dense(4, name='dense_1',
                    kernel_regularizer='l1',
>                   bias_regularizer='l2')(a)

test_training.py:1027: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x00000171973B5748>
shape = (3, 4), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
_____________________________ test_target_tensors _____________________________

    def test_target_tensors():
        # single-output, as list
        model = keras.models.Sequential()
>       model.add(keras.layers.Dense(4, input_shape=(4,), name='dense'))

test_training.py:1177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\sequential.py:166: in add
    layer(x)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x00000171976EF320>
shape = (4, 4), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
______________________ test_model_custom_target_tensors _______________________

    @pytest.mark.skipif(K.backend() == 'tensorflow' and
                        tf.__version__.startswith('2'),
                        reason='Cannot have tensors as dict keys in TF2')
    def test_model_custom_target_tensors():
        a = Input(shape=(3,), name='input_a')
        b = Input(shape=(3,), name='input_b')
    
>       a_2 = Dense(4, name='dense_1')(a)

test_training.py:1258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x0000017197650EF0>
shape = (3, 4), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
__________________ test_trainable_weights_count_consistency ___________________

    @pytest.mark.skipif(sys.version_info < (3,),
                        reason='Cannot catch warnings in python 2')
    def test_trainable_weights_count_consistency():
        """Tests the trainable weights consistency check of Model.
    
        This verifies that a warning is shown if model.trainable is modified
        and the model is summarized/run without a new call to .compile()
    
        Reproduce issue #8121
        """
        a = Input(shape=(3,), name='input_a')
>       model1 = Model(inputs=a, outputs=Dense(1)(a))

test_training.py:1324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x000001719760F8D0>
shape = (3, 1), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
____________________________ test_pandas_dataframe ____________________________

    def test_pandas_dataframe():
        input_a = Input(shape=(3,), name='input_a')
        input_b = Input(shape=(3,), name='input_b')
    
>       x = Dense(4, name='dense_1')(input_a)

test_training.py:1361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x0000017195848400>
shape = (3, 4), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
________ test_training_and_eval_methods_on_symbolic_tensors_single_io _________

    @pytest.mark.skipif(K.backend() != 'tensorflow', reason='Requires TensorFlow')
    def test_training_and_eval_methods_on_symbolic_tensors_single_io():
        x = keras.layers.Input(shape=(3,), name='input')
>       y = keras.layers.Dense(4, name='dense')(x)

test_training.py:1439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x00000171977CE4A8>
shape = (3, 4), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
_________ test_training_and_eval_methods_on_symbolic_tensors_multi_io _________

    @pytest.mark.skipif(K.backend() != 'tensorflow', reason='Requires TensorFlow')
    def test_training_and_eval_methods_on_symbolic_tensors_multi_io():
        a = keras.layers.Input(shape=(3,), name='input_a')
        b = keras.layers.Input(shape=(3,), name='input_b')
    
        dense = keras.layers.Dense(4, name='dense')
>       c = dense(a)

test_training.py:1466: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x000001719757E860>
shape = (3, 4), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
___________________________ test_dynamic_set_inputs ___________________________

    def test_dynamic_set_inputs():
        model = Sequential()
>       model.add(Dense(16, input_dim=32))

test_training.py:1639: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\sequential.py:166: in add
    layer(x)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x000001719753E9E8>
shape = (32, 16), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
____________________________ test_validation_freq _____________________________

    def test_validation_freq():
        model = Sequential([Dense(1)])
        model.compile('sgd', 'mse')
    
        def _gen():
            while True:
                yield np.ones((2, 10)), np.ones((2, 1))
    
        x, y = np.ones((10, 10)), np.ones((10, 1))
    
        class ValCounter(Callback):
    
            def __init__(self):
                self.val_runs = 0
    
            def on_test_begin(self, logs=None):
                self.val_runs += 1
    
        # Test in training_arrays.py
        val_counter = ValCounter()
        model.fit(
            x,
            y,
            batch_size=2,
            epochs=4,
            validation_data=(x, y),
            validation_freq=2,
>           callbacks=[val_counter])

test_training.py:1720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:1154: in fit
    batch_size=batch_size)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:504: in _standardize_user_data
    self._set_inputs(x)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:416: in _set_inputs
    self.build(input_shape=(None,) + inputs.shape[1:])
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\sequential.py:222: in build
    x = layer(x)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x000001719E01B6D8>
shape = (10, 1), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
_______________________ test_model_metrics_list_in_call _______________________

    def test_model_metrics_list_in_call():
    
        class TestModel(Model):
    
            def __init__(self):
                super(TestModel, self).__init__(name='test_model')
                self.dense1 = keras.layers.Dense(2)
    
            def call(self, x):
                self.add_metric(K.sum(x), name='metric_2')
                return self.dense1(x)
    
        model = TestModel()
        model.compile(
            loss='mse',
            optimizer='adam',
            metrics=[metrics.MeanSquaredError('metric_1')])
        x = np.ones(shape=(10, 1))
        y = np.ones(shape=(10, 2))
>       model.fit(x, y, epochs=2, batch_size=5, validation_data=(x, y))

test_training.py:1822: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:1154: in fit
    batch_size=batch_size)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:504: in _standardize_user_data
    self._set_inputs(x)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\training.py:463: in _set_inputs
    outputs = self.call(unpack_singleton(self.inputs))
test_training.py:1813: in call
    return self.dense1(x)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463: in __call__
    self.build(unpack_singleton(input_shapes))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895: in build
    constraint=self.kernel_constraint)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279: in add_weight
    weight = K.variable(initializer(shape, dtype=dtype),
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <keras.initializers.VarianceScaling object at 0x000001719781C908>
shape = (1, 2), dtype = 'float32'

    def __call__(self, shape, dtype=None):
        fan_in, fan_out = _compute_fans(shape)
        scale = self.scale
        if self.mode == 'fan_in':
            scale /= max(1., fan_in)
        elif self.mode == 'fan_out':
            scale /= max(1., fan_out)
        else:
>           scale /= max(1., float(fan_in + fan_out) / 2)
E           TypeError: unsupported operand type(s) for /=: 'NoneType' and 'float'

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218: TypeError
============================== warnings summary ===============================
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\_pytest\config\__init__.py:1040
  C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\_pytest\config\__init__.py:1040: PytestAssertRewriteWarning: Module already imported so cannot be rewritten: flaky
    self._mark_plugins_for_rewrite(hook)

-- Docs: https://docs.pytest.org/en/stable/warnings.html
===Flaky Test Report===

test_model_methods failed and was not selected for rerun.
	<class 'TypeError'>
	unsupported operand type(s) for /=: 'NoneType' and 'float'
	[<TracebackEntry C:\Users\mutation\Desktop\testcase\tests\keras\engine\test_training.py:165>, <TracebackEntry C:\Users\mutation\Desktop\testcase\tests\keras\engine\test_training.py:135>, <TracebackEntry C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463>, <TracebackEntry C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895>, <TracebackEntry C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279>, <TracebackEntry C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218>]
test_fit_generator failed and was not selected for rerun.
	<class 'TypeError'>
	unsupported operand type(s) for /=: 'NoneType' and 'float'
	[<TracebackEntry C:\Users\mutation\Desktop\testcase\tests\keras\engine\test_training.py:474>, <TracebackEntry C:\Users\mutation\Desktop\testcase\tests\keras\engine\test_training.py:135>, <TracebackEntry C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:463>, <TracebackEntry C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\layers\core.py:895>, <TracebackEntry C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\engine\base_layer.py:279>, <TracebackEntry C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:218>]

===End Flaky Test Report===
=========================== short test summary info ===========================
FAILED test_training.py::test_model_methods - TypeError: unsupported operand ...
FAILED test_training.py::test_fit_generator - TypeError: unsupported operand ...
FAILED test_training.py::test_fit_generator_shape - TypeError: unsupported op...
FAILED test_training.py::test_training_with_loss_instance - TypeError: unsupp...
FAILED test_training.py::test_trainable_argument - TypeError: unsupported ope...
FAILED test_training.py::test_with_list_as_targets - TypeError: unsupported o...
FAILED test_training.py::test_model_with_input_feed_tensor - TypeError: unsup...
FAILED test_training.py::test_model_with_partial_loss - TypeError: unsupporte...
FAILED test_training.py::test_model_with_external_loss - TypeError: unsupport...
FAILED test_training.py::test_target_tensors - TypeError: unsupported operand...
FAILED test_training.py::test_model_custom_target_tensors - TypeError: unsupp...
FAILED test_training.py::test_trainable_weights_count_consistency - TypeError...
FAILED test_training.py::test_pandas_dataframe - TypeError: unsupported opera...
FAILED test_training.py::test_training_and_eval_methods_on_symbolic_tensors_single_io
FAILED test_training.py::test_training_and_eval_methods_on_symbolic_tensors_multi_io
FAILED test_training.py::test_dynamic_set_inputs - TypeError: unsupported ope...
FAILED test_training.py::test_validation_freq - TypeError: unsupported operan...
FAILED test_training.py::test_model_metrics_list_in_call - TypeError: unsuppo...
============ 18 failed, 15 passed, 1 skipped, 1 warning in 10.06s =============
