2020-10-03 16:29:05.535088: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cudart64_100.dll
============================= test session starts =============================
platform win32 -- Python 3.6.12, pytest-6.0.2, py-1.9.0, pluggy-0.13.1
rootdir: C:\Users\mutation\Desktop\testcase\tests\keras
plugins: flaky-3.7.0
collected 36 items

initializers_test.py ......FF............................                [100%]

================================== FAILURES ===================================
______________________________ test_constant[FC] ______________________________

tensor_shape = (200, 100)

    @pytest.mark.parametrize('tensor_shape', [FC_SHAPE, CONV_SHAPE], ids=['FC', 'CONV'])
    def test_constant(tensor_shape):
        _runner(initializers.Constant(2), tensor_shape,
>               target_mean=2, target_max=2, target_min=2)

initializers_test.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
initializers_test.py:16: in _runner
    variable = K.variable(init(shape))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:60: in __call__
    return K.constant(self.value, shape=shape, dtype=dtype)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:649: in constant
    value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\keras\backend.py:929: in constant
    return constant_op.constant(value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = tf.float32, shape = (200, 100), verify_shape = False
allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
_____________________________ test_constant[CONV] _____________________________

tensor_shape = (25, 25, 20, 20)

    @pytest.mark.parametrize('tensor_shape', [FC_SHAPE, CONV_SHAPE], ids=['FC', 'CONV'])
    def test_constant(tensor_shape):
        _runner(initializers.Constant(2), tensor_shape,
>               target_mean=2, target_max=2, target_min=2)

initializers_test.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
initializers_test.py:16: in _runner
    variable = K.variable(init(shape))
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\initializers.py:60: in __call__
    return K.constant(self.value, shape=shape, dtype=dtype)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\keras\backend\tensorflow_backend.py:649: in constant
    value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\keras\backend.py:929: in constant
    return constant_op.constant(value, dtype=dtype, shape=shape, name=name)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:227: in constant
    allow_broadcast=True)
C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\constant_op.py:265: in _constant_impl
    allow_broadcast=allow_broadcast))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

values = None, dtype = tf.float32, shape = (25, 25, 20, 20)
verify_shape = False, allow_broadcast = True

    @tf_export("make_tensor_proto")
    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,
                          allow_broadcast=False):
      """Create a TensorProto.
    
      In TensorFlow 2.0, representing tensors as protos should no longer be a
      common workflow. That said, this utility function is still useful for
      generating TF Serving request protos:
    
        request = tensorflow_serving.apis.predict_pb2.PredictRequest()
        request.model_spec.name = "my_model"
        request.model_spec.signature_name = "serving_default"
        request.inputs["images"].CopyFrom(tf.make_tensor_proto(X_new))
    
      make_tensor_proto accepts "values" of a python scalar, a python list, a
      numpy ndarray, or a numpy scalar.
    
      If "values" is a python scalar or a python list, make_tensor_proto
      first convert it to numpy ndarray. If dtype is None, the
      conversion tries its best to infer the right numpy data
      type. Otherwise, the resulting numpy array has a compatible data
      type with the given dtype.
    
      In either case above, the numpy ndarray (either the caller provided
      or the auto converted) must have the compatible type with dtype.
    
      make_tensor_proto then converts the numpy array to a tensor proto.
    
      If "shape" is None, the resulting tensor proto represents the numpy
      array precisely.
    
      Otherwise, "shape" specifies the tensor's shape and the numpy array
      can not have more elements than what "shape" specifies.
    
      Args:
        values:         Values to put in the TensorProto.
        dtype:          Optional tensor_pb2 DataType value.
        shape:          List of integers representing the dimensions of tensor.
        verify_shape:   Boolean that enables verification of a shape of values.
        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector
            broadcasting. Cannot be true when verify_shape is true.
    
      Returns:
        A `TensorProto`. Depending on the type, it may contain data in the
        "tensor_content" attribute, which is not directly useful to Python programs.
        To access the values you should convert the proto back to a numpy ndarray
        with `tf.make_ndarray(proto)`.
    
        If `values` is a `TensorProto`, it is immediately returned; `dtype` and
        `shape` are ignored.
    
      Raises:
        TypeError:  if unsupported types are provided.
        ValueError: if arguments have inappropriate values or if verify_shape is
         True and shape of values is not equals to a shape from the argument.
    
      """
      if allow_broadcast and verify_shape:
        raise ValueError("allow_broadcast and verify_shape are not both allowed.")
      if isinstance(values, tensor_pb2.TensorProto):
        return values
    
      if dtype:
        dtype = dtypes.as_dtype(dtype)
    
      is_quantized = (
          dtype in [
              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,
              dtypes.qint32
          ])
    
      if _is_array_like(values):
        values = np.asarray(values)
    
      # We first convert value to a numpy array or scalar.
      if isinstance(values, (np.ndarray, np.generic)):
        if dtype and dtype.is_numpy_compatible:
          nparray = values.astype(dtype.as_numpy_dtype)
        else:
          nparray = values
      else:
        if values is None:
>         raise ValueError("None values not supported.")
E         ValueError: None values not supported.

C:\ProgramData\Anaconda3\envs\keras\lib\site-packages\tensorflow_core\python\framework\tensor_util.py:437: ValueError
=========================== short test summary info ===========================
FAILED initializers_test.py::test_constant[FC] - ValueError: None values not ...
FAILED initializers_test.py::test_constant[CONV] - ValueError: None values no...
======================== 2 failed, 34 passed in 4.72s =========================
